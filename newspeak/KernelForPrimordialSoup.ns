(* The core library. Notably includes the classes for representing programs, such as classes, mixins and methods. *)
class KernelForPrimordialSoup = (|
public messageLoop <MessageLoop>
public symbolTable <WeakArray[Symbol]>
private symbolTableUsed
|) (
(* An activation record for a method or closure.

Note this class only contains accessors and the logic needed for unwind-protect and exceptions. The debugger's simulator that is normally implemented in this class in Smalltalks is instead in the mirrors module. *)
public class Activation _cannotInstantiate = (
(*|
sender <Activation | nil>
bci <SmallInteger | nil>
method <Method | nil>
closure <Closure | nil>
receiver <Object>
numTemps <SmallInteger>
<temps>
|*)
) (
(* Sent by the VM if a non-local return would cross an unwind-protect activation. *)
(* :vmEntryPoint: *)
private aboutToReturn: result through: firstUnwindActivation = (
	^home return: result
)
public bci = (
	(* :pragma: primitive: 168 *)
	panic.
)
public bci: value = (
	(* :pragma: primitive: 169 *)
	panic.
)
(* Sent by the VM if attempting to return to nil sender, or a sender that has already returned. Also triggered if non-local return attempts to return to an activation that can no longer be reached along the chain of senders. *)
(* :vmEntryPoint: *)
private cannotReturn: result = (
	^(CannotReturn result: result) signal
)
public closure = (
	(* :pragma: primitive: 172 *)
	panic.
)
public closure: value = (
	(* :pragma: primitive: 173 *)
	panic.
)
(* Return the next unwind marked above the receiver, returning nil if there is none.  Search proceeds up to but not including aContext. *)
public findNextUnwindContextUpTo: activation = (
	| ctx |
	ctx:: self.
	[nil = (ctx:: ctx sender) or: [ctx = activation]]
		whileFalse:
			[ctx isUnwindContext ifTrue: [^ctx]].
	^nil
)
(* Answer whether the receiver is strictly above context on the stack. *)
public hasSender: context = (
	| s |
	self = context ifTrue: [^false].
	s:: sender.
	[nil = s]
		whileFalse:
			[s = context ifTrue: [^true].
			s:: s sender].
	^false
)
public home ^<Activation> = (
	| a c |
	a:: self.
	[c:: a closure.
	 nil = c] whileFalse:
		[a:: definingActivationOf: c].
	^a
)
public isDead ^<Boolean> = (
	^nil = bci
)
public isUnwindContext ^<Boolean> = (
	^162 = method primitive
)
public method = (
	(* :pragma: primitive: 170 *)
	panic.
)
public method: value = (
	(* :pragma: primitive: 171 *)
	panic.
)
(* Sent by the VM if the top of stack is neither true or false when a branch bytecode is reached. *)
(* :vmEntryPoint: *)
private nonBooleanReceiver: nonBoolean = (
	^(NonBooleanReceiver receiver: nonBoolean) signal
)
(* Squeak compatibility for DebugMapper. *)
public outerContext ^<Activation> = (
	| c = closure. |
	nil = c ifTrue: [^nil].
	^definingActivationOf: c
)
public pop = (
	|
	depth = self size.
	result = self tempAt: depth.
	|
	self size: depth - 1.
	^result
)
public printString ^<String> = (
	| methodMixin receiverMixin result |
	nil = closure ifFalse:
		[^'[] in ', (definingActivationOf: closure) printString].
	methodMixin:: method mixin.
	receiverMixin:: (mixinOf: (classOf: receiver)).
	result:: receiverMixin _name.
	methodMixin = receiverMixin ifFalse:
		[result:: result, '(', methodMixin _name, ')'].
	result:: result, ' ', method selector.
	#doesNotUnderstand: = method selector ifTrue:
		[self size > 0 ifTrue:
			[result:: result, ' #', (tempAt: 1) selector]].
	^result
)
public push: value = (
	| newDepth |
	newDepth:: self size + 1.
	self size: newDepth.
	^self tempAt: newDepth put: value
)
public receiver = (
	(* :pragma: primitive: 174 *)
	panic.
)
public receiver: value = (
	(* :pragma: primitive: 175 *)
	panic.
)
public resume: value = (
	| unwindActivation unwindBlock |
	self isDead ifTrue: [self cannotReturn: value to: self].
	unwindActivation:: currentActivation.
	[unwindActivation:: unwindActivation findNextUnwindContextUpTo: self.
	nil = unwindActivation]
		whileFalse:
			[nil = (unwindActivation tempAt: 2) ifTrue: [
				unwindActivation tempAt: 2 put: true.
				unwindBlock:: unwindActivation tempAt: 1.
				currentActivation terminateTo: unwindActivation.
				unwindBlock value]].
	currentActivation terminateTo: self.
	^value
)
public return: value = (
	nil = sender ifTrue: [^self cannotReturn: value].
	^sender resume: value
)
public sender = (
	(* :pragma: primitive: 166 *)
	panic.
)
public sender: value = (
	(* :pragma: primitive: 167 *)
	panic.
)
public size = (
	(* :pragma: primitive: 178 *)
	panic.
)
public size: newDepth = (
	(* :pragma: primitive: 179 *)
	panic.
)
public tempAt: index = (
	(* :pragma: primitive: 176 *)
	^(ArgumentError value: index) signal
)
public tempAt: index put: value = (
	(* :pragma: primitive: 177 *)
	^(ArgumentError value: index) signal
)
(* Make myself unresumable. *)
public terminate = (
	sender:: nil.
	bci:: nil.
	(* Match the interpreter's behavior. Note this differs from Cog, which keeps the parameters. *)
	size:: 0.
)
(* Terminate all the Contexts between me and previousContext, if previousContext is on my Context stack. Make previousContext my sender. *)
public terminateTo: previousContext = (
	| currentContext sendingContext |
	(self hasSender: previousContext) ifTrue: [
		currentContext:: sender.
		[currentContext = previousContext] whileFalse: [
			sendingContext:: currentContext sender.
			currentContext terminate.
			currentContext:: sendingContext]].
	sender:: previousContext
)
public top = (
	^self tempAt: self size
)
) : (
public new ^<Activation> = (
	(* :pragma: primitive: 180 *)
	panic.
)
)
public class ArgumentError value: v = Exception (|
	argument = v.
|) (
public printString = (
	^'ArgumentError: ', argument printString
)
) : (
public new = (
	^self value: nil
)
)
(* A mutable, fixed-length sequence of arbitrary elements. *)
(* :exemplar: {1. 2. 3} *)
public class Array _cannotInstantiate = Collection (
) (
(* Concatenation. *)
public , collection = (
	|
	newArray = Array new: self size + collection size.
	offset = self size.
	|
	newArray replaceFrom: 1 to: self size with: self startingAt: 1.
	1 to: collection size do:
		[:index | newArray at: index + offset put: (collection at: index)].
	^newArray
)
public asArray ^<Array[E]> = (
	^self
)
public at: index <Integer> ^<E> = (
	(* :pragma: primitive: 69 *)
	^(ArgumentError value: index) signal
)
public at: index <Integer> put: value <E> ^<E> = (
	(* :pragma: primitive: 70 *)
	^(ArgumentError value: index) signal
)
public collect: transform <[:E | F]> ^<Array[F]> = (
	| results = Array new: size. |
	1 to: size do:
		[:index |
		results at: index put: (transform value: (self at: index))].
	^results
)
public copyFrom: start <Integer> to: stop <Integer> ^<Array[E]> = (
	(* :pragma: primitive: 73 *)
	^ArgumentError new signal
)
public copyWith: newElement <E> ^<Array[E]> = (
	|
	newArray = Array new: 1 + self size.
	|
	newArray replaceFrom: 1 to: self size with: self startingAt: 1.
	newArray at: newArray size put: newElement.
	^newArray
)
public copyWithSize: newSize <Integer> ^<Array[E]> = (
	|
	newArray = Array new: newSize.
	overlap = size < newSize ifTrue: [size] ifFalse: [newSize].
	|
	^newArray replaceFrom: 1 to: overlap with: self startingAt: 1
)
public do: action <[:E]> = (
	1 to: self size do: [:index | action value: (self at: index)].
)
public first ^<E> = (
	^self at: 1
)
public indexOf: element <E> ^<Integer> = (
	1 to: self size do: [:index | (self at: index) = element ifTrue: [^index]].
	^0
)
public isEmpty ^<Boolean> = (
	^0 = self size
)
public isKindOfArray ^<Boolean> = (
	^true
)
public keysAndValuesDo: action <[:Integer :E]> = (
	1 to: self size do: [:index | action value: index value: (self at: index)].
)
public last ^<E> = (
	^self at: self size
)
private merge: source into: destination start: start mid: mid stop: stop by: lessOrEqual = (
	| leftCursor rightCursor |
	leftCursor:: start.
	rightCursor:: 1 + mid.
	start to: stop do:
		[:destCursor |
		 leftCursor <= mid ifFalse:
			[^destination replaceFrom: destCursor to: stop with: source startingAt: rightCursor].
		 rightCursor <= stop ifFalse:
			[^destination replaceFrom: destCursor to: stop with: source startingAt: leftCursor].
		 (lessOrEqual value: (source at: leftCursor) value: (source at: rightCursor))
			ifTrue:
				[destination at: destCursor put: (source at: leftCursor).
				 leftCursor:: 1 + leftCursor]
			ifFalse:
				[destination at: destCursor put: (source at: rightCursor).
				 rightCursor:: 1 + rightCursor]].
)
public reject: predicate <[:E | Boolean]> ^<Array[E]> = (
	| result cursor |
	result:: Array new: self size.
	cursor:: 0.
	1 to: self size do:
		[:index | | element <E> |
		 element:: self at: index.
		 (predicate value: element) ifFalse:
			[result at: (cursor:: 1 + cursor) put: element]].
	^result copyFrom: 1 to: cursor
)
public replaceFrom: start <Integer> to: stop <Integer> with: replacement <Array> startingAt: replacementStart <Integer> = (
	(* :pragma: primitive: 72 *)
	^ArgumentError new signal
)
public select: predicate <[:E | Boolean]> ^<Array[E]> = (
	| result cursor |
	result:: Array new: self size.
	cursor:: 0.
	1 to: self size do:
		[:index | | element <E> |
		 element:: self at: index.
		 (predicate value: element) ifTrue:
			[result at: (cursor:: 1 + cursor) put: element]].
	^result copyFrom: 1 to: cursor
)
public size ^<Integer> = (
	(* :pragma: primitive: 71 *)
	panic.
)
public sort: lessOrEqual <[:E :E | Boolean]> = (
	self sortFrom: 1 to: self size by: lessOrEqual.
)
private sort: source into: destination from: start to: stop by: lessOrEqual = (
	| mid |
	start >= stop ifTrue: [^self].
	mid:: (start + stop) // 2.
	self sort: destination into: source from: start to: mid by: lessOrEqual.
	self sort: destination into: source from: 1 + mid to: stop by: lessOrEqual.
	self merge: source into: destination start: start mid: mid stop: stop by: lessOrEqual.
)
public sortFrom: start to: stop by: lessOrEqual <[:E :E | Boolean]> = (
	self sort: (self copyWithSize: stop - start + 1) into: self from: start to: stop by: lessOrEqual.
)
) : (
public new: size <Integer> ^<Array[E]> = (
	(* :pragma: primitive: 66 *)
	^(ArgumentError value: size) signal
)
public withAll: collection <Collection[E]> ^<Array[E]> = (
	| result index |
	result:: Array new: collection size.
	index:: 1.
	collection do: [:element <E> | result at: index put: element. index:: 1 + index].
	^result
)
)
(* My instances describe the shape and behavior of other objects. *)
public class Behavior = (
|
private superclass <Behavior> (* Must be slot 1, known to the VM. *)
private methods <Array[Method]> (* Must be slot 2, known to the VM. *)
private enclosingObject <Object> (* Must be slot 3, known to the VM. *)
private mixin <AbstractMixin> (* Must be slot 4, known to the VM. *)
private classIndex <SmallInteger> (* Must be slot 5, known to the VM. *)
private format <SmallInteger> (* Must be slot 6, known to the VM. *)
|) (
public isKindOfBehavior = (
	^true
)
public mixinApply: superklass = (
	(* :todo: To be subsumed by generalized mixin application support. *)
	^self mixin apply: superklass withName: self name enclosingObject: self enclosingObject.
)
) : (
)
public class Boolean = () (
public isKindOfBoolean ^<Boolean> = (
	^true
)
) : (
)
(* A mutable, fixed-length sequence of integers between 0 and 255. *)
(* :exemplar: (ByteArray new: 3) at: 1 put: 1; at: 2 put: 2; yourself *)
public class ByteArray _cannotInstantiate = Collection (
) (
public asByteArray ^<ByteArray> = (
	^self
)
public asString ^<String> = (
	^self copyStringFrom: 1 to: size
)
public at: index <Integer> ^<Integer> = (
	(* :pragma: primitive: 113 *)
	^(ArgumentError value: index) signal
)
public at: index <Integer> put: value <Integer> ^<Integer> = (
	(* :pragma: primitive: 114 *)
	^(ArgumentError value: index) signal
)
public copyByteArrayFrom: start <Integer> to: stop <Integer> ^<String> = (
	(* :pragma: primitive: 109 *)
	^ArgumentError new signal
)
public copyFrom: start <Integer> to: stop <Integer> ^<String> = (
	(* :pragma: primitive: 109 *)
	^ArgumentError new signal
)
public copyStringFrom: start <Integer> to: stop <Integer> ^<String> = (
	(* :pragma: primitive: 108 *)
	^ArgumentError new signal
)
public copyWithSize: newSize <Integer> ^<ByteArray> = (
	|
	newArray = ByteArray new: newSize.
	overlap = size < newSize ifTrue: [size] ifFalse: [newSize].
	|
	^newArray replaceFrom: 1 to: overlap with: self startingAt: 1
)
public do: action <[:Integer]> = (
	1 to: self size do: [:index <Integer> | action value: (self at: index)].
)
public endsWith: suffix <ByteArray | String> ^<Boolean> = (
	(* :pragma: primitive: 105 *)
	^(ArgumentError value: suffix) signal
)
public float32At: offset <Integer> ^<Float> = (
	(* :pragma: primitive: 100 *)
	^(ArgumentError value: offset) signal
)
public float32At: offset <Integer> put: value <Float> ^<Float> = (
	(* :pragma: primitive: 101 *)
	^(ArgumentError value: offset) signal
)
public float64At: offset <Integer> ^<Float> = (
	(* :pragma: primitive: 102 *)
	^(ArgumentError value: offset) signal
)
public float64At: offset <Integer> put: value <Float> ^<Float> = (
	(* :pragma: primitive: 103 *)
	^(ArgumentError value: offset) signal
)
public indexOf: substring <ByteArray | String> ^<Integer> = (
	^self indexOf: substring startingAt: 1
)
public indexOf: substring <ByteArray | String> startingAt: index <Integer> ^<Integer> = (
	(* :pragma: primitive: 106 *)
	^ArgumentError new signal
)
public int16At: offset <Integer> ^<Integer> = (
	(* :pragma: primitive: 94 *)
	^(ArgumentError value: offset) signal
)
public int16At: offset <Integer> put: value <Integer> ^<Integer> = (
	(* :pragma: primitive: 95 *)
	^(ArgumentError value: offset) signal
)
public int32At: offset <Integer> ^<Integer> = (
	(* :pragma: primitive: 96 *)
	^(ArgumentError value: offset) signal
)
public int32At: offset <Integer> put: value <Integer> ^<Integer> = (
	(* :pragma: primitive: 97 *)
	^(ArgumentError value: offset) signal
)
public int64At: offset <Integer> ^<Integer> = (
	(* :pragma: primitive: 98 *)
	^(ArgumentError value: offset) signal
)
public int64At: offset <Integer> put: value <Integer> ^<Integer> = (
	(* :pragma: primitive: 99 *)
	^(ArgumentError value: offset) signal
)
public int8At: offset <Integer> ^<Integer> = (
	(* :pragma: primitive: 92 *)
	^(ArgumentError value: offset) signal
)
public int8At: offset <Integer> put: value <Integer> ^<Integer> = (
	(* :pragma: primitive: 93 *)
	^(ArgumentError value: offset) signal
)
public isEmpty ^<Boolean> = (
	^0 = self size
)
public isKindOfByteArray ^<Boolean> = (
	^true
)
public lastIndexOf: substring <ByteArray | String> ^<Integer> = (
	^self lastIndexOf: substring startingAt: 1 + self size
)
public lastIndexOf: substring <ByteArray | String> startingAt: index <Integer> ^<Integer> = (
	(* :pragma: primitive: 107 *)
	^ArgumentError new signal
)
public replaceFrom: start <Integer> to: stop <Integer> with: replacement <ByteArray | String> startingAt: replacementStart <Integer> = (
	(* :pragma: primitive: 116 *)
	^ArgumentError new signal
)
public size ^<Integer> = (
	(* :pragma: primitive: 115 *)
	panic.
)
public startsWith: prefix <ByteArray | String> ^<Boolean> = (
	(* :pragma: primitive: 104 *)
	^(ArgumentError value: prefix) signal
)
public uint16At: offset <Integer> ^<Integer> = (
	(* :pragma: primitive: 86 *)
	^(ArgumentError value: offset) signal
)
public uint16At: offset <Integer> put: value <Integer> ^<Integer> = (
	(* :pragma: primitive: 87 *)
	^(ArgumentError value: offset) signal
)
public uint32At: offset <Integer> ^<Integer> = (
	(* :pragma: primitive: 88 *)
	^(ArgumentError value: offset) signal
)
public uint32At: offset <Integer> put: value <Integer> ^<Integer> = (
	(* :pragma: primitive: 89 *)
	^(ArgumentError value: offset) signal
)
public uint64At: offset <Integer> ^<Integer> = (
	(* :pragma: primitive: 90 *)
	^(ArgumentError value: offset) signal
)
public uint64At: offset <Integer> put: value <Integer> ^<Integer> = (
	(* :pragma: primitive: 91 *)
	^(ArgumentError value: offset) signal
)
public uint8At: offset <Integer> ^<Integer> = (
	(* :pragma: primitive: 84 *)
	^(ArgumentError value: offset) signal
)
public uint8At: offset <Integer> put: value <Integer> ^<Integer> = (
	(* :pragma: primitive: 85 *)
	^(ArgumentError value: offset) signal
)
) : (
public new: size <Integer> ^<ByteArray> = (
	(* :pragma: primitive: 110 *)
	^(ArgumentError value: size) signal
)
public withAll: bytes <Collection[Integer] | ByteArray | String> ^<ByteArray> = (
	(* :pragma: primitive: 112 *)
	| result index |
	result:: ByteArray new: bytes size.
	index:: 1.
	bytes do: [:element <E> | result at: index put: element. index:: 1 + index].
	^result
)
)
(* Signalled when attempting to return to (or through) a nil sender or a sender that has already returned. *)
class CannotReturn result: r = Exception (
|
public result = r.
|) (
public printString ^<String> = (
	^'CannotReturn: ', result printString
)
) : (
)
(* The superclass of all metaclasses. *)
(* :exemplar: Object *)
public class Class = Behavior (
|
private nameS <Symbol> (* Must be slot 7, known to the VM for debug printing only. *)
private subclasses <WeakArray>
|) (
(* Sent by the compiler from factory methods. *)
protected basicNew = (
	(* :pragma: primitive: 140 *)
	panic.
)
public name ^<String> = (
	^self nameS
)
public printString ^<String> = (
	^nameS
)
) : (
)
(* A class-side mixin is the difference between a metaclass and Class. (In Newspeak metaclasses are direct subclasses of Class, unlike Smalltalk where they are subclasses of the class's superclass's metaclass.) Note that class-side mixins can only introduce additional methods, unlike instance-side mixins which can introduce slots, methods and nested classes. Because of this, module definitions (top-level classes) are always stateless.

Raw mixins are not user accessible. Mixins are implicitly extracted from a class during mixin application. *)
public class ClassMixin = (
|
public _instanceMixin <InstanceMixin>
public _methods <Array[Method]> (* Must be slot 2, known to the VM. *)
public _enclosingMixin <InstanceMixin | nil> (* Must be slot 3, known to the VM. *)
|) (
public _name ^<String> = (
	^_instanceMixin _name, ' class'
)
public _nestedMixins ^<Array[InstanceMixin]> = (
	^{}
)
public _slots ^<Array[{Symbol. Boolean. Symbol}]> = (
	^{}
)
public isMeta ^<Boolean> = (
	^true
)
) : (
)
(* A piece of delayed code; sometimes called a `block`. *)
(* :exemplar: [3 + 4] *)
public class Closure _cannotInstantiate = (
) (
(* Invoke this closure with 1 or fewer arguments. *)
public cull: arg1 = (
	0 = numArgs ifTrue: [^self value].
	1 = numArgs ifTrue: [^self value: arg1].
	^numArgsError: 1
)
(* Invoke this closure with 2 or fewer arguments. *)
public cull: arg1 cull: arg2 = (
	0 = numArgs ifTrue: [^self value].
	1 = numArgs ifTrue: [^self value: arg1].
	2 = numArgs ifTrue: [^self value: arg1 value: arg2].
	^numArgsError: 2
)
(* Invoke this closure with 3 or fewer arguments. *)
public cull: arg1 cull: arg2 cull: arg3 = (
	0 = numArgs ifTrue: [^self value].
	1 = numArgs ifTrue: [^self value: arg1].
	2 = numArgs ifTrue: [^self value: arg1 value: arg2].
	3 = numArgs ifTrue: [^self value: arg1 value: arg2 value: arg3].
	^numArgsError: 3
)
(* Invoke this closure, and invoke the argument on normal return or if non-local return or exception handling would skip over normal return. *)
public ensure: onUnwind <[]> = (
	(* :pragma: primitive: 162 *)
	| complete result |
	result:: self value.
	nil = complete ifTrue:
		[complete:: true.
		onUnwind value].
	^result
)
public isKindOfClosure ^<Boolean> = (
	^true
)
public numArgs ^<Integer> = (
	(* :pragma: primitive: 152 *)
	panic.
)
private numArgsError: argsProvided = (
	(* :bogus: *)
	^(ArgumentError value: self) signal
)
(* Exception handling. *)
public on: exceptionClass <E class> do: catch <[:E]> = (
	(* :pragma: primitive: 161 *)
	| handlerActive ::= true. |
	^self value
)
public printString ^<String> = (
	^'[closure] in ', (definingActivationOf: self) printString
)
(* Looping. *)
(* :inlineBytecode: *)
public repeat = (
	(* Usually this message is implemented inline by the bytecode compiler, and therefore not subject to lookup. This implementation handles non-inlined cases, such as eventual sends or non-literal receivers. *)
	^[self value] repeat
)
(* Invoke this closure with no arguments. *)
public value = (
	(* :pragma: primitive: 156 *)
	self numArgs = 0 ifFalse: [^numArgsError: 0].
	panic.
)
(* Invoke this closure with 1 argument. *)
public value: arg1 = (
	(* :pragma: primitive: 157 *)
	self numArgs = 1 ifFalse: [^numArgsError: 1].
	panic.
)
(* Invoke this closure with 2 arguments. *)
public value: arg1 value: arg2 = (
	(* :pragma: primitive: 158 *)
	self numArgs = 2 ifFalse: [^numArgsError: 2].
	panic.
)
(* Invoke this closure with 3 arguments. *)
public value: arg1 value: arg2 value: arg3 = (
	(* :pragma: primitive: 159 *)
	self numArgs = 3 ifFalse: [^numArgsError: 3].
	panic.
)
(* Invoke this closure with a variable number of arguments. *)
public valueWithArguments: arguments = (
	(* :pragma: primitive: 160 *)
	self numArgs = arguments size ifFalse: [^numArgsError: arguments size].
	^self valueWithArgumentsAgain: (Array withAll: arguments)
)
private valueWithArgumentsAgain: arguments = (
	(* :pragma: primitive: 160 *)
	self numArgs = arguments size ifFalse: [^numArgsError: arguments size].
	panic.
)
(* Looping. *)
(* :inlineBytecode: *)
public whileFalse = (
	(* Usually this message is implemented inline by the bytecode compiler, and therefore not subject to lookup. This implementation handles non-inlined cases, such as eventual sends or non-literal receivers. *)
	^[self value] whileFalse
)
(* Looping. *)
(* :inlineBytecode: *)
public whileFalse: action <[]> = (
	(* Usually this message is implemented inline by the bytecode compiler, and therefore not subject to lookup. This implementation handles non-inlined cases, such as eventual sends or non-literal receivers/arguments. *)
	^[self value] whileFalse: [action value]
)
(* Looping. *)
(* :inlineBytecode: *)
public whileTrue = (
	(* Usually this message is implemented inline by the bytecode compiler, and therefore not subject to lookup. This implementation handles non-inlined cases, such as eventual sends or non-literal receivers. *)
	^[self value] whileTrue
)
(* Looping. *)
(* :inlineBytecode: *)
public whileTrue: action <[]> = (
	(* Usually this message is implemented inline by the bytecode compiler, and therefore not subject to lookup. This implementation handles non-inlined cases, such as eventual sends or non-literal receivers/arguments. *)
	^[self value] whileTrue: [action value]
)
) : (
)
(* An enumerable group of elements. All operations are defined in terms of `do:`. *)
public class Collection = (
) (
public allSatisfy: predicate <[:E | Boolean]> ^<Boolean> = (
	self do: [:element <E> | (predicate value: element) ifFalse: [^false]].
	^true
)
public anySatisfy: predicate <[:E | Boolean]> ^<Boolean> = (
	self do: [:element <E> | (predicate value: element) ifTrue: [^true]].
	^false
)
public collect: transform <[:E | F]> ^<List[F]> = (
	| result <List[E]> |
	result:: self newForCollectUsingAdd: size.
	self do: [:element <E> | result add: (transform value: element)].
	^result
)
public detect: predicate <[:E | Boolean]> ^<E> = (
	^self detect: predicate ifNone: [Exception signal: 'No matching element detected']
)
public detect: predicate <[:E | Boolean]> ifNone: onNone <[X def]> ^<E | X> = (
	self do: [:element <E> | (predicate value: element) ifTrue: [^element]].
	^onNone value
)
public do: action <[:E]> = (
	self subclassResponsibility.
)
public do: action <[:E]> separatedBy: betweenAction <[]> = (
	| first <Boolean> ::= true. |
	self do:
		[:element <E> |
		 first ifTrue: [first:: false] ifFalse: [betweenAction value].
		 action value: element].
)
public includes: object <Object> ^<Boolean> = (
	self do: [:element <E> | element = object ifTrue: [^true]].
	^false
)
public inject: initialValue <X> into: foldBlock <[:X def :E | X]> ^<X> = (
	| runningValue <X> ::= initialValue. |
	self do: [:element <E> | runningValue:: foldBlock value: runningValue value: element].
	^runningValue
)
public isEmpty ^<Boolean> = (
	self do: [:ignore | ^false].
	^true
)
public isKindOfCollection ^<Boolean> = (
	^true
)
public noneSatisfy: predicate <[:E | Boolean]> ^<Boolean> = (
	self do: [:element <E> | (predicate value: element) ifTrue: [^false]].
	^true
)
public reduce: mergeFunction <[:(E | X) :E | X def]> ^<X> = (
	^self reduce: mergeFunction ifEmpty: [Exception signal: 'Cannot reduce an empty collection' ]
)
public reduce: mergeFunction <[:(E | X) :E | X def]> ifEmpty: onEmpty <[Y def]> ^<E | X | Y> = (
	| first <Boolean> ::= true. runningValue <E | X> |
	self do:
		[:element <E> |
		first
			ifTrue: [runningValue:: element. first:: false]
			ifFalse: [runningValue:: mergeFunction value: runningValue value: element]].
	^first
		ifTrue: [onEmpty value]
		ifFalse: [runningValue]
)
public reject: predicate <[:E | Boolean]> ^<List[E]> = (
	| result <List[E]> |
	result:: self newForCollectUsingAdd: size.
	self do: [:element <E> | (predicate value: element) ifFalse: [result add: element]].
	^result
)
public select: predicate <[:E | Boolean]> ^<List[E]> = (
	| result <List[E]> |
	result:: self newForCollectUsingAdd: size.
	self do: [:element <E> | (predicate value: element) ifTrue: [result add: element]].
	^result
)
public size ^<Integer> = (
	| count ::= 0. |
	self do: [:ignore | count:: count + 1].
	^count
)
) : (
)
(* If `key` is reachable from some other object, then `value` is reachable. *)
public class Ephemeron = (
|
public key (* Must be slot 1, known to the VM. *)
public value (* Must be slot 2, known to the VM. *)
public finalizer (* Must be slot 3, known to the VM. *)
(* Must have no other slots. Can be subclassed, but subclasses won't have the ephemeron property. *)
|) (
) : (
)
public class Exception = (|
private signalActivation <Activation>
private handlerActivation <Activation>
public messageText (* squeak compatibility for Minitest *)
|) (
private invokeNextHandler = (
	| activation <Activation> |

	activation:: handlerActivation sender.
	[nil = activation] whileFalse:
		[activation method primitive = 163 ifTrue:
			[returnToSimulationRoot: activation.
			 panic].
		 activation method primitive = 161 ifTrue:
			[(is: (activation tempAt: 1) interestedIn: super class) ifTrue:
				[(activation tempAt: 3) ifTrue:
					[^invokeOnDoHandler: activation]]].
		 activation:: activation sender].

	messageLoop unhandledException: self from: signalActivation sender.
	panic.
)
private invokeOnDoHandler: handler <Activation> = (
	| handlerResult |
	handler tempAt: 3 put: false. (* handlerActive:: false. *)
	handlerActivation:: handler.
	handlerResult:: (handler tempAt: 2) value: self.
	handler tempAt: 3 put: true. (* handlerActive:: true. *)
	(* What if the return is interrupted by unwind-protect? Should we hold off on removing these activations and check if they are dead instead? *)
	signalActivation:: nil.
	handlerActivation:: nil.
	^handler return: handlerResult
)
private is: handlerExceptionClass <Any> interestedIn: signaledExceptionClass <Behavior> = (
	| cls mxn |
	cls:: classOf: handlerExceptionClass.
	Metaclass = cls ifTrue: [^false (* [handlerExceptionClass] is a metaclass *)].
	cls:: classOf: cls.
	Metaclass = cls ifFalse: [^false (* [handlerExceptionClass] is an instance *)].
	mxn:: mixinOf: handlerExceptionClass.
	cls:: signaledExceptionClass.
	[(mixinOf: cls) = mxn ifTrue: [^true].
	 cls:: (superclassOf: cls).
	 nil = cls] whileFalse.
	^false
)
private jumpTo: activation = (
	(* :pragma: primitive: 165 *)
	panic.
)
(* Yield control to the next enclosing #on:do: handler. *)
public pass = (
	nil = handlerActivation ifTrue: [^error].
	invokeNextHandler.
	panic.
)
public printString ^<String> = (
	nil = messageText ifTrue: [^super class name].
	^super class name, ': ', messageText
)
(* Returns the argument to the sender of #signal. *)
public resume: resumptionValue = (
	| savedSignalActivation = signalActivation. |
	nil = savedSignalActivation ifTrue: [^error].
	signalActivation:: nil.
	handlerActivation:: nil.
	^savedSignalActivation return: resumptionValue
)
public retry = (
	panic. (* Needs test *)
	handlerActivation restart.
	panic.
)
(* Returns the argument as the result of the current #on:do: message. *)
public return: returnValue = (
	| savedHandlerActivation = handlerActivation. |
	nil = handlerActivation ifTrue: [^error].
	signalActivation:: nil.
	handlerActivation:: nil.
	^savedHandlerActivation return: returnValue
)
private returnToSimulationRoot: simulationRoot <Activation> = (
	(simulationRoot tempAt: 1)
		state: #broken;
		suspendedActivation: signalActivation sender.

	(* Note the following alternative doesn't work. Slow stepping will stop
	   after the sender is changed, because it leaves the stepping goal off
       the chain, and overwrite the suspened activation, because we didn't stop
	   at the simulation root.
		currentActivation sender: simulationRoot.
		^self *)

	simulationRoot push: self.
	jumpTo: simulationRoot.
)
(* Yields control to an enclosing #on:do: handler. *)
public signal = (
	handlerActivation:: signalActivation:: currentActivation.
	invokeNextHandler.
	panic.
)
(* squeak compatibility for Minitest *)
public signal: message <String> = (
	messageText:: message.
	^self signal
)
) : (
public signal: message <String> = (
	^(self new messageText: message) signal
)
)
(* Defines the behavior of `false`. *)
(* :exemplar: false *)
public class False _cannotInstantiate = Boolean (
) (
(* Evaluating conjunction. *)
public & alternative <Boolean> ^<Boolean> = (
	^false
)
(* Non-evaluating conjunction. *)
public and: alternative <[Boolean]> ^<Boolean> = (
	^false
)
public asString ^<String> = (
	^'false'
)
(* Branching. *)
(* :inlineBytecode: *)
public ifFalse: else <[Y def]> ^<nil | Y> = (
	(* Usually this message is implemented inline by the bytecode compiler, and therefore not subject to lookup. This implementation handles non-inlined cases, such as eventual sends or non-literal arguments. *)
	^else value
)
(* Branching. *)
(* :inlineBytecode: *)
public ifFalse: else <[Y def]> ifTrue: then <[X def]> ^<X | Y> = (
	(* Usually this message is implemented inline by the bytecode compiler, and therefore not subject to lookup. This implementation handles non-inlined cases, such as eventual sends or non-literal arguments. *)
	^else value
)
(* Branching. *)
(* :inlineBytecode: *)
public ifTrue: then <[X def]> ^<X | nil> = (
	(* Usually this message is implemented inline by the bytecode compiler, and therefore not subject to lookup. This implementation handles non-inlined cases, such as eventual sends or non-literal arguments. *)
	^nil
)
(* Branching. *)
(* :inlineBytecode: *)
public ifTrue: then <[X def]> ifFalse: else <[Y def]> ^<X | Y> = (
	(* Usually this message is implemented inline by the bytecode compiler, and therefore not subject to lookup. This implementation handles non-inlined cases, such as eventual sends or non-literal arguments. *)
	^else value
)
(* Negation. *)
public not ^<Boolean> = (
	^true
)
(* Non-evaluating disjunction. *)
public or: alternative <[Boolean]> ^<Boolean> = (
	^alternative value
)
public printString ^<String> = (
	^'false'
)
(* Evaluating disjunction. *)
public | alternative <Boolean> ^<Boolean> = (
	^alternative
)
) : (
)
(* A double-precision floating point number. *)
(* :exemplar: 1 exp *)
public class Float _cannotInstantiate = Number (
) (
public acos ^<Float> = (
	(* :pragma: primitive: 41 *)
	panic.
)
public addFromFraction: left <Fraction> ^<Number> = (
	^left asFloat + self
)
public asFloat ^<Float> = (
	^self
)
public asStringExponential: fractionDigits <Integer> ^<String> = (
	(* :pragma: primitive: 56 *)
	^(ArgumentError value: fractionDigits) signal
)
public asStringFixed: fractionDigits <Integer> ^<String> = (
	(* :pragma: primitive: 55 *)
	^(ArgumentError value: fractionDigits) signal
)
public asStringPrecision: precision <Integer> ^<String> = (
	(* :pragma: primitive: 57 *)
	^(ArgumentError value: precision) signal
)
public asin ^<Float> = (
	(* :pragma: primitive: 40 *)
	panic.
)
public atan ^<Float> = (
	(* :pragma: primitive: 42 *)
	panic.
)
public atan: y <Number> ^<Float> = (
	(* :pragma: primitive: 43 *)
	^atanAgain: y asFloat
)
private atanAgain: y <Float> ^<Float> = (
	(* :pragma: primitive: 43 *)
	^(ArgumentError value: y) signal
)
(* Round toward positive infinity. *)
public ceiling ^<Float> = (
	(* :pragma: primitive: 33 *)
	panic.
)
(* Cosine in radians. *)
public cos ^<Float> = (
	(* :pragma: primitive: 38 *)
	panic.
)
public divideFromFraction: left <Fraction> ^<Number> = (
	^left asFloat / self
)
(* Answer e raised to the power of the receiver. *)
public exp ^<Float> = (
	(* :pragma: primitive: 50 *)
	panic.
)
(* Round toward negative infinity. *)
public floor ^<Float> = (
	(* :pragma: primitive: 32 *)
	panic.
)
public hash ^<Integer> = (
	^self asInteger
)
public isFinite ^<Boolean> = (
	(* :pragma: primitive: 58 *)
	panic.
)
public isInfinite ^<Boolean> = (
	(* :pragma: primitive: 59 *)
	panic.
)
public isKindOfFloat ^<Boolean> = (
	^true
)
public isNaN ^<Boolean> = (
	^(self = self) not
)
(* Answer the natural logarithm of the receiver. *)
public ln ^<Float> = (
	(* :pragma: primitive: 51 *)
	panic.
)
(* Answer the common logarithm of the receiver. *)
public log ^<Float> = (
	(* :pragma: primitive: 52 *)
	panic.
)
public multiplyFromFraction: left <Fraction> ^<Number> = (
	^left asFloat * self
)
private pow: exponent <Float> ^<Float> = (
	(* :pragma: primitive: 54 *)
	^(ArgumentError value: exponent) signal
)
(* Exponentiation. *)
public raisedTo: exponent <Number> ^<Float> = (
	^self pow: exponent asFloat
)
(* Answer the receiver rounded to the nearest integer value, ties to max magnitude. *)
public rounded ^<Float> = (
	(* :pragma: primitive: 35 *)
	panic.
)
(* Answer the sine of the receiver measured in radians. *)
public sin ^<Float> = (
	(* :pragma: primitive: 37 *)
	panic.
)
(* Answer the square root of the receiver. *)
public sqrt ^<Float> = (
	(* :pragma: primitive: 53 *)
	panic.
)
public subtractFromFraction: left <Fraction> ^<Number> = (
	^left asFloat - self
)
(* Answer the tangent of the receiver measured in radians. *)
public tan ^<Float> = (
	(* :pragma: primitive: 39 *)
	panic.
)
) : (
public parse: string <String> ^<Float> = (
	(* :pragma: primitive: 63 *)
	^(ArgumentError value: string) signal
)
)
(* A rational number. *)
(* :exemplar: 3/4 *)
public class Fraction reducedNumerator: num denominator: denom = Number (
|
public numerator <Integer> = num.
public denominator <Integer> = denom.
|) (
public * other <Number> ^<Number> = (
	other isKindOfFraction ifFalse: [^other multiplyFromFraction: self].
	^Fraction
		numerator: numerator * other numerator
		denominator: denominator * other denominator
)
public + other <Number> ^<Number> = (
	other isKindOfFraction ifFalse: [^other addFromFraction: self].
	^Fraction
		numerator: (numerator * other denominator) + (other numerator * denominator)
		denominator: denominator * other denominator
)
public - other <Number> ^<Number> = (
	other isKindOfFraction ifFalse: [^other subtractFromFraction: self].
	^Fraction
		numerator: (numerator * other denominator) - (other numerator * denominator)
		denominator: denominator * other denominator
)
public / other <Number> ^<Number> = (
	other isKindOfFraction ifFalse: [^other divideFromFraction: self].
	^Fraction
		numerator: numerator * other denominator
		denominator: denominator * other numerator
)
public < other <Number> ^<Boolean> = (
	other isKindOfInteger ifTrue:
		[^(numerator) < (other * denominator)].
	other isKindOfFraction ifTrue:
		[^(numerator * other denominator) < (other numerator * denominator)].
	other isKindOfFloat ifTrue:
		[^self asFloat < other].
	^(ArgumentError value: other) signal
)
public <= other <Number> ^<Boolean> = (
	other isKindOfInteger ifTrue:
		[^(numerator) <= (other * denominator)].
	other isKindOfFraction ifTrue:
		[^(numerator * other denominator) <= (other numerator * denominator)].
	other isKindOfFloat ifTrue:
		[^self asFloat <= other].
	^(ArgumentError value: other) signal
)
public = other ^<Boolean> = (
	other isKindOfFraction ifFalse: [^false].
	numerator = other numerator ifFalse: [^false].
	^denominator = other denominator
)
public > other <Number> ^<Boolean> = (
	other isKindOfInteger ifTrue:
		[^(numerator) > (other * denominator)].
	other isKindOfFraction ifTrue:
		[^(numerator * other denominator) > (other numerator * denominator)].
	other isKindOfFloat ifTrue:
		[^self asFloat > other].
	^(ArgumentError value: other) signal
)
public >= other <Number> ^<Boolean> = (
	other isKindOfInteger ifTrue:
		[^(numerator) >= (other * denominator)].
	other isKindOfFraction ifTrue:
		[^(numerator * other denominator) >= (other numerator * denominator)].
	other isKindOfFloat ifTrue:
		[^self asFloat >= other].
	^(ArgumentError value: other) signal
)
public addFromNumber: left = (
	^(left * denominator + numerator) / denominator
)
public asFloat ^<Float> = (
	^numerator asFloat / denominator asFloat
)
(* Round toward zero (truncation). *)
public asInteger ^<Integer> = (
	^self truncated
)
public asString ^<String> = (
	^'(', numerator asString, '/', denominator asString, ')'
)
(* Round toward positive infinity. *)
public ceiling ^<Integer> = (
	^0 <= numerator
		ifTrue: [1 + self truncated]
		ifFalse: [self truncated]
)
public divideFromNumber: left = (
	^(left * denominator) / numerator
)
(* Round toward negative infinity. *)
public floor ^<Integer> = (
	^numerator // denominator
)
public hash ^<Integer> = (
	(* :todo: This is a poor hash. *)
	^numerator bitXor: denominator
)
public isKindOfFraction ^<Boolean> = (
	^true
)
public multiplyFromNumber: left = (
	^(left * numerator) / denominator
)
public rounded ^<Integer> = (
	^0 <= numerator
		ifTrue: [(2 * numerator + denominator) quo: (2 * denominator)]
		ifFalse: [(2 * numerator - denominator) quo: (2 * denominator)].
)
public subtractFromNumber: left = (
	^(left * denominator - numerator) / denominator
)
public truncated ^<Integer> = (
	^numerator quo: denominator
)
) : (
public numerator: numerator <Integer> denominator: denominator <Integer> ^<Fraction> = (
	(* Invariant: instances of Fraction must always be in reduced form. *)
	| gcd numer denom |
	0 = numerator ifTrue: [^0].
	gcd:: numerator gcd: denominator.
	numer:: numerator // gcd.
	denom:: denominator // gcd.
	0 > denom ifTrue:
		[numer:: 0 - numer.
		 denom:: 0 - denom].
	1 = denom ifTrue: [^numer].
	^Fraction reducedNumerator: numer denominator: denom
)
)
(* A map whose keys are considered equal according to object identity. *)
public class IdentityMap new: capacity = (
|
table ::= Array new: capacity.
public size ::= 0.
|
1 to: table size do: [:index | table at: index put: table]
) (
public at: key = (
	| table mask index entry |
	table:: self table.
	mask:: table size - 2.
	index:: (identityHashOf: key) & mask + 1.
	[entry:: table at: index.
	 (is: entry identicalTo: key) ifTrue: [^table at: 1 + index].
	 table = entry] whileFalse:
		[index:: index + 2 & mask + 1].

	noSuchKey
)
public at: key ifAbsent: onAbsent = (
	| table mask index entry value |
	table:: self table.
	mask:: table size - 2.
	index:: (identityHashOf: key) & mask + 1.
	[entry:: table at: index.
	 (is: entry identicalTo: key) ifTrue: [^table at: index + 1].
	 table = entry] whileFalse:
		[index:: index + 2 & mask + 1].

	^onAbsent value
)
public at: key ifAbsentPut: valueGen = (
	| table mask index entry value |
	table:: self table.
	mask:: table size - 2.
	index:: (identityHashOf: key) & mask + 1.
	[entry:: table at: index.
	 (is: entry identicalTo: key) ifTrue: [^table at: index + 1].
	 table = entry] whileFalse:
		[index:: index + 2 & mask + 1].

	value:: valueGen value.
	table at: index put: key.
	table at: index + 1 put: value.
	size:: size + 1.
	(size) > (table size * 3 / 8) ifTrue: [self grow].
	^value
)
public at: key ifAbsentPutVal: value = (
	| table mask index entry |
	table:: self table.
	mask:: table size - 2.
	index:: (identityHashOf: key) & mask + 1.
	[entry:: table at: index.
	 (is: entry identicalTo: key) ifTrue: [^false].
	 table = entry] whileFalse:
		[index:: index + 2 & mask + 1].

	table at: index put: key.
	table at: index + 1 put: value.
	size:: size + 1.
	(size) > (table size * 3 / 8) ifTrue: [self grow].
	^true
)
public at: key put: value = (
	(at: key ifAbsentPutVal: value) ifFalse: [duplicateKey].
	^value
)
public at: key putReplace: value = (
	| table mask index entry |
	table:: self table.
	mask:: table size - 2.
	index:: (identityHashOf: key) & mask + 1.
	[entry:: table at: index.
	 (is: entry identicalTo: key) ifTrue: [^table at: index + 1 put: value].
	 table = entry] whileFalse:
		[index:: index + 2 & mask + 1].

	noSuchKey
)
public atOrItself: key = (
	| table mask index entry |
	table:: self table.
	mask:: table size - 2.
	index:: (identityHashOf: key) & mask + 1.
	[entry:: table at: index.
	 (is: entry identicalTo: key) ifTrue: [^table at: 1 + index].
	 table = entry] whileFalse:
		[index:: index + 2 & mask + 1].

	^key
)
grow = (
	| oldTable newSize mask newTable |
	oldTable:: table.
	newSize:: oldTable size * 2.
	mask:: newSize - 2.
	newTable:: Array new: newSize.
	1 to: newSize do: [:index | newTable at: index put: newTable].

	1 to: oldTable size by: 2 do: [:oldIndex |
		| key |
		key:: oldTable at: oldIndex.
		oldTable = key ifFalse:
			[ | value newIndex |
			 value:: oldTable at: oldIndex + 1.
			 newIndex:: (identityHashOf: key) & mask + 1.
			 [newTable = (newTable at: newIndex)] whileFalse:
				[newIndex:: newIndex + 2 & mask + 1].
			 newTable at: newIndex put: key.
			 newTable at: newIndex + 1 put: value]].
	table:: newTable.
)
public includesKey: key = (
	| table mask index entry |
	table:: self table.
	mask:: table size - 2.
	index:: (identityHashOf: key) & mask + 1.
	[entry:: table at: index.
	 (is: entry identicalTo: key) ifTrue: [^true].
	 table = entry] whileFalse:
		[index:: index + 2 & mask + 1].

	^false
)
public keysAndValuesDo: action <[:K :V]> = (
	1 to: table size by: 2 do: [:index |
		| key = table at: index. |
		table = key ifFalse:
			[action value: key value: (table at: 1 + index)]].
)
) : (
public new = (
	^self new: 32
)
)
(* An instance-side mixin is the difference between a (non-meta) class and its superclass: a set of additional methods, slots and nested class declarations. Instance-side mixins always have a paired class-side mixin.

Raw mixins are not user accessible. Mixins are implicitly extracted from a class during mixin application. *)
public class InstanceMixin = (
|
public _name <Symbol>
public _methods <Array[Method]> (* Must be slot 2, known to the VM. *)
public _enclosingMixin <InstanceMixin | nil> (* Must be slot 3, known to the VM. *)
public _slots <Array[{Symbol. Boolean. Symbol}]>
public _nestedMixins <Array[InstanceMixin]>
public _applications <WeakArray>
public _classMixin <ClassMixin>
public _accessModifier <Symbol>
public _primaryFactorySelector <Symbol>
public _headerSource <String>
|) (
public apply: superclass <Class> format: f withName: name <Symbol> enclosingObject: eo <Object> = (
	| newMetaclass <Metaclass> newClass <Class> |
	newMetaclass:: Metaclass new.
	superclassOf: newMetaclass put: Class.
	methodsOf: newMetaclass put: _classMixin _methods. (* Do we need a copy? *)
	enclosingObjectOf: newMetaclass put: eo.
	mixinOf: newMetaclass put: _classMixin.
	formatOf: newMetaclass put: (formatOf: Class).

	newClass:: instantiate: newMetaclass.
	superclassOf: newClass put: superclass.
	methodsOf: newClass put: (methodsWithAccessorsAtOffset: f).
	enclosingObjectOf: newClass put: eo.
	mixinOf: newClass put: self.
	formatOf: newClass put: f + _slots size.
	nameOf: newClass put: name.

	thisClassOf: newMetaclass put: newClass.

	_applications:: toWeakSet: _applications add: newClass.
	nil = superclass ifFalse:
		[subclassesOf: superclass put: (toWeakSet: (subclassesOf: superclass) add: newClass)].

	^newClass
)
(* Sent by the compiler in nested class accessors. *)
public apply: nestedMixinName to: superclass <Class> withEnclosingObject: eo <Object> = (
	_nestedMixins do:
		[:nestedMixin |
			nestedMixin _name = nestedMixinName ifTrue:
				[^nestedMixin applyTo: superclass withEnclosingObject: eo]].
	panic.
)
public apply: superclass <Class> withName: name <Symbol> enclosingObject: eo <Object> = (
	(isValidSuperclass: superclass) ifFalse: [^(ArgumentError value: superclass) signal].
	^self apply: superclass format: (formatOf: superclass) withName: name enclosingObject: eo
)
public applyTo: superclass <Class> withEnclosingObject: eo <Object> = (
	^apply: superclass withName: _name enclosingObject: eo
)
public isMeta ^<Boolean> = (
	^false
)
private isValidSuperclass: object = (
	| cls cid |
	cls:: classOf: object.
	Metaclass = cls ifTrue: [^false (* [object] is a metaclass *)].
	cls:: classOf: cls.
	Metaclass = cls ifFalse: [^false (* [object] is an instance *)].
	cid:: slotOf: object at: 5.
	nil = cid ifTrue: [^true].
	^(cid between: 3 and: 13) not
)
private methodsWithAccessorsAtOffset: offset <Integer> ^<MethodDictionary> = (
	| newMethods <MethodDictionary> methodIndex |
	newMethods:: Array new: _methods size.

	methodIndex:: 1.
	1 to: _slots size do: [:i |
		| slot name accessModifier |
		slot:: _slots at: i.
		name:: slot name.
		accessModifier:: slot accessModifier.

		newMethods at: methodIndex put:
			(Method newGetterForSlot: name at: i + offset accessModifier: accessModifier).
		methodIndex:: methodIndex + 1.
		newMethods at: methodIndex put:
			(Method newInitializerForSlot: name at: i + offset).
		methodIndex:: methodIndex + 1.
		slot isMutable ifTrue:
			[newMethods at: methodIndex put:
				(Method newSetterForSlot: name at: i + offset accessModifier: accessModifier).
			methodIndex:: methodIndex + 1]].

	_methods do:
		[:method |
		| skip ::= false. |
		1 to: methodIndex - 1 do:
			[:i |
			(newMethods at: i) selector = method selector ifTrue:
				[skip:: true]].
		skip ifFalse:
			[newMethods at: methodIndex put: method.
			methodIndex:: methodIndex + 1]].

	^newMethods
)
public printString ^<String> = (
	^_name, ' mixin'
)
private toWeakSet: set add: element = (
	| newSet |
	nil = set ifTrue:
		[newSet:: WeakArray new: 2.
		newSet at: 1 put: element.
		^newSet].
	1 to: set size do:
		[:index |
		nil = (set at: index) ifTrue:
			[set at: index put: element.
			 ^set]].
	^set copyWith: element
)
) : (
)
(* Integers are represented by my subclasses: SmallInteger, MediumInteger and LargeInteger. *)
(* :exemplar: 1984 *)
class Integer = Number (
) (
(* Bitwise and. *)
public & other <Integer> ^<Integer> = (
	(* :pragma: primitive: 20 *)
	^(ArgumentError value: other) signal
)
public / other <Number> ^<Number> = (
	(* :pragma: primitive: 4 *)
	other isKindOfInteger ifFalse: [^other divideFromNumber: self].
	0 = other ifTrue: [^(ArgumentError value: other) signal].
	^Fraction numerator: self denominator: other
)
(* Shift left. *)
public << other <Integer> ^<Integer> = (
	(* :pragma: primitive: 23 *)
	^(ArgumentError value: other) signal
)
(* Shift right arithmetic. *)
public >> other <Integer> ^<Integer> = (
	(* :pragma: primitive: 24 *)
	^(ArgumentError value: other) signal
)
public addFromFraction: left <Fraction> ^<Number> = (
	^(left numerator + (self * left denominator)) / left denominator
)
(* Round toward zero (truncation). *)
public asInteger ^<Integer> = (
	^self
)
public asStringRadix: radix <Integer> ^<String> = (
	| value result index |
	10 = radix ifTrue: [^self asString].
	radix < 2 ifTrue: [^(ArgumentError value: radix) signal].
	radix > 36 ifTrue: [^(ArgumentError value: radix) signal].
	self < 0 ifTrue: [^'-', ((0 - self) asStringRadix: radix)].
	value:: self.
	result:: ''.
	[index:: 1 + (value \\ radix).
	 result:: ('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' copyFrom: index to: index) , result.
	 value:: value // radix.
	 value > 0] whileTrue.
	^result
)
(* Bitwise and. *)
public bitAnd: other <Integer> ^<Integer> = (
	(* :pragma: primitive: 20 *)
	^(ArgumentError value: other) signal
)
(* Bitwise complement. *)
public bitInvert ^<Integer> = (
	^-1 - self
)
(* Bitwise inclusive or. *)
public bitOr: other <Integer> ^<Integer> = (
	(* :pragma: primitive: 21 *)
	^(ArgumentError value: other) signal
)
(* Bitwise exclusive or. *)
public bitXor: other <Integer> ^<Integer> = (
	(* :pragma: primitive: 22 *)
	^(ArgumentError value: other) signal
)
(* Round toward positive infinity. *)
public ceiling ^<Integer> = (
	^self
)
public denominator ^<Integer> = (
	^1
)
(* Answer the index'th digit in base 256. *)
public digitAt: index <Integer> ^<Integer> = (
	(* :pragma: primitive: 28 *)
	^(ArgumentError value: index) signal
)
(* Answer the number of digits in base 256. *)
public digitLength ^<Integer> = (
	(* :pragma: primitive: 29 *)
	panic.
)
public divideFromFraction: left <Fraction> ^<Number> = (
	^left numerator / (left denominator * self)
)
(* Round toward negative infinity. *)
public floor ^<Integer> = (
	^self
)
(* Greatest common divisor *)
public gcd: other <Integer> ^<Integer> = (
	(* Euclidean algorithm *)
	| n m |
	n:: self.
	m:: other.
	[n = 0] whileFalse: [n:: m \\ (m:: n)].
	^m abs
)
public hash ^<Integer> = (
	^self
)
public isKindOfFraction ^<Boolean> = (
	^true
)
public isKindOfInteger ^<Boolean> = (
	^true
)
public multiplyFromFraction: left <Fraction> ^<Number> = (
	^(left numerator * self) / left denominator
)
public numerator ^<Integer> = (
	^self
)
(* Modular exponentiation *)
public raisedTo: exponent <Integer> modulo: modulus <Integer> ^<Integer | Fraction> = (
	| result base e |
	base:: self \\ modulus.
	exponent < 0 ifTrue: [^(base reciprocalModulo: modulus) raisedTo: 0 - exponent modulo: modulus].
	result:: 1.
	e:: exponent.
	[e > 0] whileTrue:
		[0 = (e & 1) ifFalse: [result:: result * base \\ modulus].
		 e:: e >> 1.
		 base:: base * base \\ modulus].
	^result
)
(* Modular multiplicative inverse *)
public reciprocalModulo: modulus <Integer> ^<Integer> = (
	(* Extended Euclidean algorithm *)
	| t newt r newr |
	t:: 0.
	newt:: 1.
	r:: modulus.
	newr:: self.
	[0 = newr] whileFalse:
		[ | q tmp |
		 q:: r // newr.
		 tmp:: newt.
		 newt:: t - (q * newt).
		 t:: tmp.
		 tmp:: newr.
		 newr:: r - (q * newr).
		 r:: tmp].
	r > 1 ifTrue: [^Exception signal: 'Not coprime'].
	t < 0 ifTrue: [t:: t + modulus].
	^t
)
public rounded ^<Integer> = (
	^self
)
public subtractFromFraction: left <Fraction> ^<Number> = (
	^(left numerator - (self * left denominator)) / left denominator
)
(* Looping. *)
(* :inlineBytecode: *)
public timesRepeat: action <[]> ^<Integer> = (
	(* Usually this message is implemented inline by the bytecode compiler, and therefore not subject to lookup. This implementation handles non-inlined cases, such as eventual sends or non-literal arguments. *)
	1 to: self do: [:ignore | action value].

	^nil (* To match the inlined version *)
)
(* Answer the bitwise inclusive or of the receiver and argument in two's complement form. *)
public | other <Integer> ^<Integer> = (
	(* :pragma: primitive: 21 *)
	^(ArgumentError value: other) signal
)
) : (
private digitValue: byte <Integer> ^<Integer> = (
	byte >= 48 ifTrue: [byte <= 57 ifTrue: [^byte - 48]].
	byte >= 65 ifTrue: [byte <= 90 ifTrue: [^byte - 55]].
	byte >= 97 ifTrue: [byte <= 122 ifTrue: [^byte - 87]].
	^37
)
public parse: string <String> ^<Integer> = (
	^self parse: string radix: 10
)
public parse: string <String> radix: radix <Integer> ^<Integer> = (
	| negative start value |
	radix < 2 ifTrue: [^(ArgumentError value: radix) signal].
	radix > 36 ifTrue: [^(ArgumentError value: radix) signal].
	string size = 0 ifTrue: [^(ArgumentError value: string) signal].
	45 = (string at: 1)
		ifTrue:
			[negative:: true.
			 string size < 2 ifTrue: [^(ArgumentError value: string) signal].
			 start:: 2]
		ifFalse:
			[negative:: false.
			 start:: 1].
	value:: 0.
	start to: string size do:
		[:index | | digitValue = self digitValue: (string at: index). |
		digitValue >= radix ifTrue: [^(ArgumentError value: string) signal].
		value:: value * radix + digitValue].
	^negative ifTrue: [0 - value] ifFalse: [value]
)
)
(* An arbitrary-precision integer. *)
(* :exemplar: 1 << 64 *)
public class LargeInteger _cannotInstantiate = Integer (
) (
) : (
)
(* An integer representable as a 64-bit two's complement number. *)
(* :exemplar: 1 << 63 - 1 *)
public class MediumInteger _cannotInstantiate = Integer (
) (
) : (
)
public class Message selector: s arguments: a = (|
public selector <Symbol> = s.
public arguments <Array[Object]> = a.
|) (
private object: receiver perform: selector with: arguments = (
	(* :pragma: primitive: 134 *)
	^object: receiver perform: selector asSymbol withAgain: (Array withAll: arguments)
)
private object: receiver perform: selector withAgain: arguments = (
	(* :pragma: primitive: 134 *)
	panic.
)
(* Immediate, ordinary send. *)
public sendTo: receiver = (
	^object: receiver perform: selector with: arguments
)
(* Eventual, ordinary send. *)
public sendToEventual: receiver = (
	^messageLoop eventualSendTo: receiver selector: selector arguments: arguments
)
) : (
)
(* Signalled by Object>>doesNotUnderstand:. *)
public class MessageNotUnderstood receiver: r message: m = Exception (
|
public receiver <Object> = r.
public message <Message> = m.
|) (
(* squeak compatibility for Minitest *)
public messageText ^<String> = (
	^self printString
)
public printString ^<String> = (
	^'MessageNotUnderstood: ', (mixinOf: (classOf: receiver)) _name, ' ', message selector
)
) : (
)
(* The class of all metaclasses. *)
public class Metaclass = Behavior (
|
private thisClass <Class>
|) (
public name ^<String> = (
	^thisClass name, ' class'
)
public printString ^<String> = (
	^thisClass printString, ' class'
)
) : (
)
public class Method = (|
public header <Integer> (* Must be slot 1, known to the VM. *)
public literals <Array> (* Must be slot 2, known to the VM. *)
public bytecode <ByteArray> (* Must be slot 3, known to the VM. *)
public mixin <AbstractMixin> (* Must be slot 4, known to the VM. *)
public selector <Symbol> (* Must be slot 5, known to the VM. *)
public metadata
|) (
public accessModifier ^<Symbol> = (
	| am = header & 3. |
	0 = am ifTrue: [^#public].
	1 = am ifTrue: [^#protected].
	2 = am ifTrue: [^#private].
	panic.
)
public isPrivate ^<Boolean> = (
	^#private = accessModifier
)
public isProtected ^<Boolean> = (
	^#protected = accessModifier
)
public isPublic ^<Boolean> = (
	^#public = accessModifier
)
public isSynthetic ^<Boolean> = (
	^nil = metadata
)
public numArgs ^<Integer> = (
	^header >> 2 & 255
)
public numTemps ^<Integer> = (
	^header >> 10 & 255
)
public primitive ^<Integer> = (
	^header >> 18
)
public source = (
	metadata isKindOfDebugInfo ifTrue: [^metadata source].
	^metadata
)
) : (
public headerForAccessModifier: am primitive: prim numArgs: numArgs = (
	| ami |
	#public = am ifTrue: [ami:: 0].
	#protected = am ifTrue: [ami:: 1].
	#private = am ifTrue: [ami:: 2].
	^(prim << 18) | (numArgs << 2) | (ami)
)
public headerForAccessModifier: am primitive: prim numTemps: numTemps numArgs: numArgs = (
	| ami |
	#public = am ifTrue: [ami:: 0].
	#protected = am ifTrue: [ami:: 1].
	#private = am ifTrue: [ami:: 2].
	^(prim << 18) | (numTemps << 10) | (numArgs << 2) | (ami)
)
public newGetterForSlot: name at: index accessModifier: am = (
	| accessor = Method new. |
	accessor header: (headerForAccessModifier: am primitive: 512 + index - 1 numArgs: 0).
	accessor mixin: self. (* The method has no sends, so this is only for debugging. *)
	accessor selector: name.
	^accessor
)
public newInitializerForSlot: name at: index = (
	| accessor = Method new. |
	accessor header: (headerForAccessModifier: #private primitive: 1024 + index - 1 numArgs: 1).
	accessor mixin: self. (* The method has no sends, so this is only for debugging. *)
	accessor selector: ('init`', name, ':') asSymbol.
	^accessor
)
public newSetterForSlot: name at: index accessModifier: am = (
	| accessor = Method new. |
	accessor header: (headerForAccessModifier: am primitive: 1024 + index - 1 numArgs: 1).
	accessor mixin: self. (* The method has no sends, so this is only for debugging. *)
	accessor selector: (name, ':') asSymbol.
	^accessor
)
)
(* Signalled when the receiver of an inlined control message (such as ifTrue:) is neither `true` nor `false`. *)
class NonBooleanReceiver receiver: r = Exception (
|
public receiver = r.
|) (
public printString ^<String> = (
	^'NonBooleanReceiver: ', receiver printString
)
) : (
)
class Number = () (
(* Multiplication. *)
public * other <Number> ^<Number> = (
	(* :pragma: primitive: 3 *)
	^other multiplyFromNumber: self
)
(* Addition. *)
public + other <Number> ^<Number> = (
	(* :pragma: primitive: 1 *)
	^other addFromNumber: self
)
(* Subtraction. *)
public - other <Number> ^<Number> = (
	(* :pragma: primitive: 2 *)
	^other subtractFromNumber: self
)
(* Division.
	 'Exact' division. For integer division see // and quo: *)
public / other <Number> ^<Number> = (
	(* :pragma: primitive: 4 *)
	^other divideFromNumber: self
)
(* Integer division, rounded toward negative infinity. The remainder of this division is given by \\ *)
public // other <Number> ^<Number> = (
	(* :pragma: primitive: 5 *)
	^(ArgumentError value: other) signal
)
public < other <Number> ^<Boolean> = (
	(* :pragma: primitive: 13 *)
	other isKindOfFraction ifTrue: [^other >= self].
	^(ArgumentError value: other) signal
)
public <= other <Number> ^<Boolean> = (
	(* :pragma: primitive: 15 *)
	other isKindOfFraction ifTrue: [^other > self].
	^(ArgumentError value: other) signal
)
public = other <Object> ^<Boolean> = (
	(* :pragma: primitive: 12 *)
	^(ArgumentError value: other) signal
)
public > other <Number> ^<Boolean> = (
	(* :pragma: primitive: 14 *)
	other isKindOfFraction ifTrue: [^other <= self].
	^(ArgumentError value: other) signal
)
public >= other <Number> ^<Boolean> = (
	(* :pragma: primitive: 16 *)
	other isKindOfFraction ifTrue: [^other < self].
	^(ArgumentError value: other) signal
)
(* Remainder of integer division rounded toward negative infinity.  The quoitent of this division is given by // *)
public \\ other <Number> ^<Number> = (
	(* :pragma: primitive: 6 *)
	^(ArgumentError value: other) signal
)
(* Absolute value. *)
public abs ^<Number> = (
	self < 0 ifTrue: [^self negated].
	^self
)
public acos ^<Float> = (
	^self asFloat acos
)
public asFloat ^<Float> = (
	(* :pragma: primitive: 18 *)
	panic.
)
(* Round toward zero (truncation). *)
public asInteger ^<Integer> = (
	(* :pragma: primitive: 17 *)
	^(ArgumentError value: self) signal
)
public asString ^<String> = (
	(* :pragma: primitive: 19 *)
	panic.
)
public asin ^<Float> = (
	^self asFloat asin
)
public atan ^<Float> = (
	^self asFloat atan
)
public atan: y ^<Float> = (
	^self asFloat atan: y
)
public between: min <Number> and: max <Number> ^<Boolean> = (
	self <= max ifFalse: [^false].
	^self >= min
)
(* Cosine in radians. *)
public cos ^<Float> = (
	^self asFloat cos
)
(* Answer e raised to the power of the receiver. *)
public exp ^<Float> = (
	^self asFloat exp
)
public isKindOfFloat ^<Boolean> = (
	^false
)
public isKindOfFraction ^<Boolean> = (
	^false
)
public isKindOfInteger ^<Boolean> = (
	^false
)
public isKindOfNumber ^<Boolean> = (
	^true
)
(* Natural logarithm. *)
public ln ^<Float> = (
	^self asFloat ln
)
(* Common logarithm. *)
public log ^<Float> = (
	^self asFloat log
)
public max: other <Number> ^<Number> = (
	^self > other ifTrue: [self] ifFalse: [other]
)
public min: other <Number> ^<Number> = (
	^self < other ifTrue: [self] ifFalse: [other]
)
public negated ^<Number> = (
	^0 - self
)
public printString ^<String> = (
	^self asString
)
(* Division, rounded toward zero. The remainder of this division is given by rem: *)
public quo: other <Number> ^<Number> = (
	(* :pragma: primitive: 7 *)
	^(ArgumentError value: other) signal
)
(* Exponentiation. *)
public raisedTo: exponent <Number> ^<Number> = (
	exponent isKindOfInteger ifTrue: [^self raisedToInteger: exponent].
	^self asFloat raisedTo: exponent
)
private raisedToInteger: exponent <Integer> ^<Integer | Fraction> = (
	| result base e |
	exponent < 0 ifTrue: [^1 / (self raisedToInteger: 0 - exponent)].
	result:: 1.
	base:: self.
	e:: exponent.
	[e > 0] whileTrue:
		[(e bitAnd: 1) = 0 ifFalse: [result:: result * base].
		 e:: e >> 1.
		 base:: base * base].
	^result
)
(* Remainder of division rounded toward zero. The quoitent of this division is given by quo: *)
public rem: other <Number> ^<Number> = (
	(* :pragma: primitive: 8 *)
	^(ArgumentError value: other) signal
)
(* Sine in radians. *)
public sin ^<Float> = (
	^self asFloat sin
)
(* Square root. *)
public sqrt ^<Float> = (
	^self asFloat sqrt
)
(* Tangent in radians. *)
public tan ^<Float> = (
	^self asFloat tan
)
(* Iteration. *)
(* :inlineBytecode: *)
public to: stop <Number> by: step <Number> do: action <[:Number]> = (
	(* Usually this message is implemented inline by the bytecode compiler, and therefore not subject to lookup. This implementation handles non-inlined cases, such as eventual sends or non-literal arguments. *)
	| current ::= self. |
	[current <= stop] whileTrue: [action value: current. current:: step + current].

	^nil (* To match the inlined version *)
)
(* Iteration. *)
(* :inlineBytecode: *)
public to: stop <Number> do: action <[:Number]> = (
	(* Usually this message is implemented inline by the bytecode compiler, and therefore not subject to lookup. This implementation handles non-inlined cases, such as eventual sends or non-literal arguments. *)
	| current ::= self. |
	[current <= stop] whileTrue: [action value: current. current:: 1 + current].

	^nil (* To match the inlined version *)
)
) : (
)
(* Object is the root of the class hierarchy and provides behavior common to all objects.

Unlike other systems inspired by Smalltalk, the number of methods in this class is deliberately kept to a minimum. Behavior should only be provided by this class if it should be considered part of the core set of features available to *all* Newspeak programmers.

The security model of the Newspeak programming language is based on capabilities and it is essential that capabilities cannot leak through behavior provided by this class. For example, this class provides no mechanism for accessing instance variables of its instances. Instead such capabilities are provided to the debugger and other tools through mirror based reflection modules.

Object has no instance variables, nor should any be added. Several subclasses of Object have special implementations and the VM on relies on their layout. Adding slots to Object would be fatal. *)
public class Object = super Object (
) (
(* Answers whether the receiver is considered equal to 'other'.
	May be overridden by subclasses, and should be overridden if the method 'hash' is overridden.
	This method must implement an equivalence relation, that is, the following must hold:
	* x = x evaluates to true
	* if x = y evaluates to true then y = x must evaluate to true
	* if x = y evaluates to true and y = z evaluates to true then x = z must evaluate to true.
	Furthermore, this method must be consistent with the implementation of hash, that is:
	* if x = y evaluates to true then x hash = y hash must evaluate to true. *)
public = other <Object> ^<Boolean> = (
	(* :pragma: primitive: 135 *)
	panic.
)
protected Array = (
	^outer KernelForPrimordialSoup Array
)
protected ByteArray = (
	^outer KernelForPrimordialSoup ByteArray
)
protected Exception = (
	^outer KernelForPrimordialSoup Exception
)
protected Float = (
	^outer KernelForPrimordialSoup Float
)
protected Integer = (
	^outer KernelForPrimordialSoup Integer
)
protected Object = (
	^outer KernelForPrimordialSoup Object
)
protected String = (
	^outer KernelForPrimordialSoup String
)
(* Return a promise to the sender's home, and resume the sender when the argument resolves. *)
protected await: promise <Promise[V]> ^<V> = (
	|
	current = currentActivation.
	continuation = current sender.
	home = continuation home.
	resolver = messageLoop Resolver new.
	|
	messageLoop Promise
		when: promise
		fulfilled:
			[:v |
			[resolver fulfill: (continue: continuation withValue: v)]
				on: Exception
				do: [:e | resolver break: e]]
		broken:
			[:e |
			[resolver fulfill: (continue: continuation withException: e)]
				on: Exception
				do: [:e | resolver break: e]].
	current sender: home sender.
	home sender: nil.
	^resolver promise
)
(* Answers the class of the receiver.

	This method is not public to make it easier to separate the authority of an instance from the authority of its class. This is similar to how the flatness of the metaclass heirarchy separates the interface of an object from the interface of its class. *)
protected class ^<Behavior> = (
	(* :pragma: primitive: 127 *)
	panic.
)
private continue: continuation withException: exception = (
	| current = currentActivation. |
	continuation home sender: current sender.
	current sender: continuation.
	^exception signal
)
private continue: continuation withValue: value = (
	| current = currentActivation. |
	continuation home sender: current sender.
	current sender: continuation.
	^value
)
(* :vmEntryPoint: *)
protected doesNotUnderstand: message <Message> = (
	0 = message arguments size ifTrue:
		[(message selector startsWith: 'isKindOf') ifTrue:
			[^false]].

	^(MessageNotUnderstood receiver: self message: message) signal
)
(* Answers the hash code for the receiver.
	May be overridden by subclasses, and should be overridden if the method '=' is overridden.
	The hash code must obey the requirements set forth in the method '=', that is, the following must hold:
	* if x = y evaluates to true then x hash = y hash must evaluate to true. *)
public hash ^<Integer> = (
	(* :pragma: primitive: 136 *)
	panic.
)
public isNil ^<Boolean> = (
	^false
)
public out = (
	print:: self printString.
)
(* printString should only be used to provide labels for objects in the development environment. Its result is Undefined Behavior and must not be parsed. If an object has a stable string representation, it should be provided by asString instead of printString. *)
public printString ^<String> = (
	(* bogus: should not rely on class not being overridden *)
	^'instance of ', class name
)
public yourself = (
	^self
)
) : (
)
(* Proxy overrides all the public members of Object with protected ones. One can implement a total proxy by subclassing and implementing only #doesNotUnderstand:. *)
public class Proxy = (
) (
protected = other = (
	^super = other
)
protected hash = (
	^super hash
)
protected isNil = (
	^super isNil
)
protected out = (
	^super out
)
protected printString = (
	^super printString
)
protected yourself = (
	^super yourself
)
) : (
)
public class SlotDeclaration = (
|
public header ::= 0.
public name
public mixin
public metadata
|
) (
public accessModifier ^<Symbol> = (
	| am = header & 3. |
	0 = am ifTrue: [^#public].
	1 = am ifTrue: [^#protected].
	2 = am ifTrue: [^#private].
	panic.
)
public accessModifier: am = (
	| ami |
	#public = am ifTrue: [ami:: 0].
	#protected = am ifTrue: [ami:: 1].
	#private = am ifTrue: [ami:: 2].
	header:: header | ami.
)
public isMutable = (
	^header >> 2 & 1 = 1
)
public isMutable: v = (
	header:: (v ifTrue: [1] ifFalse: [0]) << 2 | header.
)
public isTransient = (
	^header >> 3 & 1 = 1
)
public isTransient: v = (
	header:: (v ifTrue: [1] ifFalse: [0]) << 3 | header.
)
) : (
)
(* An integer representable as a 31-/63-bit two's complement number. *)
(* :exemplar: 1984 *)
public class SmallInteger _cannotInstantiate = Integer (
) (
) : (
)
(* An immutable, fixed-length sequence of integers between 0 and 255. Often interpreted as UTF-8. *)
(* :exemplar: 'Hello, polymerizing new world!' *)
public class String _cannotInstantiate = (
) (
(* Concatenation. *)
public , other <String> ^<String> = (
	(* :pragma: primitive: 121 *)
	^(ArgumentError value: other) signal
)
public = other <Object> ^<Boolean> = (
	(* :pragma: primitive: 120 *)
	panic.
)
public asByteArray ^<ByteArray> = (
	^self copyByteArrayFrom: 1 to: size
)
public asString ^<String> = (
	^self
)
public asSymbol ^<String> = (
	(isCanonical: self) ifTrue: [^self].
	^intern: self.
)
public at: index <Integer> ^<Integer> = (
	(* :pragma: primitive: 117 *)
	^(ArgumentError value: index) signal
)
public copyByteArrayFrom: start <Integer> to: stop <Integer> ^<String> = (
	(* :pragma: primitive: 109 *)
	^ArgumentError new signal
)
public copyFrom: start <Integer> to: stop <Integer> ^<String> = (
	(* :pragma: primitive: 108 *)
	^ArgumentError new signal
)
public copyStringFrom: start <Integer> to: stop <Integer> ^<String> = (
	(* :pragma: primitive: 108 *)
	^ArgumentError new signal
)
public do: action <[:Integer]> = (
	1 to: self size do: [:index <Integer> | action value: (self at: index)].
)
public endsWith: suffix <ByteArray | String> ^<Boolean> = (
	(* :pragma: primitive: 105 *)
	^(ArgumentError value: suffix) signal
)
private escape: code to: sb = (
	8 = code ifTrue: [^sb addByte: 92; addByte: 98]. (* \b *)
	9 = code ifTrue: [^sb addByte: 92; addByte: 116]. (* \t *)
	10 = code ifTrue: [^sb addByte: 92; addByte: 110]. (* \n" *)
	12 = code ifTrue: [^sb addByte: 92; addByte: 102]. (* \f *)
	13 = code ifTrue: [^sb addByte: 92; addByte: 114]. (* \r *)
	34 = code ifTrue: [^sb addByte: 92; addByte: 34]. (* \" *)
	92 = code ifTrue: [^sb addByte: 92; addByte: 92].  (* \\ *)
	code < 32 ifTrue:
		[^sb addByte: 92; addByte: 120;
			addByte: ('0123456789ABCDEF' at: code >> 4 + 1);
			addByte: ('0123456789ABCDEF' at: code & 15 + 1)].
	sb addByte: code.
)
public first ^<Integer> = (
	^self at: 1
)
public hash ^<Integer> = (
	(* :pragma: primitive: 119 *)
	panic.
)
public indexOf: substring <ByteArray | String> ^<Integer> = (
	^self indexOf: substring startingAt: 1
)
public indexOf: substring <ByteArray | String> startingAt: index <Integer> ^<Integer> = (
	(* :pragma: primitive: 106 *)
	^ArgumentError new signal
)
public isEmpty ^<Boolean> = (
	^0 = self size
)
public isKindOfString ^<Boolean> = (
	^true
)
public last ^<Integer> = (
	^self at: self size
)
public lastIndexOf: substring <ByteArray | String> ^<Integer> = (
	^self lastIndexOf: substring startingAt: 1 + self size
)
public lastIndexOf: substring <ByteArray | String> startingAt: index <Integer> ^<Integer> = (
	(* :pragma: primitive: 107 *)
	^ArgumentError new signal
)
public out = (
	print: self.
)
public printString ^<String> = (
	| sb = StringBuilder new. |
	sb addByte: 34.
	self do: [:code | escape: code to: sb].
	sb addByte: 34.
	^sb asString
)
public size ^<Integer> = (
	(* :pragma: primitive: 118 *)
	panic.
)
public startsWith: prefix <ByteArray | String> ^<Boolean> = (
	(* :pragma: primitive: 104 *)
	^(ArgumentError value: prefix) signal
)
) : (
public with: byte <Integer> ^<String> = (
	(* :pragma: primitive: 122 *)
	^(ArgumentError value: byte) signal
)
public withAll: bytes <Collection[Integer] | ByteArray | String> ^<String> = (
	(* :pragma: primitive: 123 *)
	^self withAllAgain: (ByteArray withAll: bytes)
)
private withAllAgain: bytes <ByteArray> ^<String> = (
	(* :pragma: primitive: 123 *)
	panic
)
)
public class StringBuilder new: capacity <Integer> = (|
protected size_ ::= 0.
protected data ::= ByteArray new: capacity.
|) (
public add: bytes <ByteArray | String> = (
	|
	capacity = data size.
	newSize = size_ + bytes size.
	|
	newSize > capacity ifTrue:
		[data:: data copyWithSize: ((capacity >> 1 + capacity) max: newSize)].
	data replaceFrom: 1 + size_ to: newSize with: bytes startingAt: 1.
	size_:: newSize.
	^bytes
)
public addByte: byte <Integer> = (
	|
	capacity = data size.
	newSize = size_ + 1.
	|
	newSize > capacity ifTrue:
		[data:: data copyWithSize: (capacity >> 1 + capacity | 7)].
	size_:: newSize.
	^data at: newSize put: byte
)
public asByteArray ^<ByteArray> = (
	^data copyFrom: 1 to: size_
)
public asString ^<String> = (
	^data copyStringFrom: 1 to: size_
)
public isEmpty ^<Boolean> = (
	^0 = size_
)
public isKindOfStringBuilder ^<Boolean> = (
	^true
)
public size ^<Integer> = (
	^size_
)
public writeln: line = (
	self add: line.
	self addByte: 10. (* Line-feed *)
)
) : (
public new ^<StringBuilder> = (
	^self new: 8
)
)
(* Defines the behavior of `true`. *)
(* :exemplar: true *)
public class True _cannotInstantiate = Boolean (
) (
(* Evaluating conjunction. *)
public & alternative <Boolean> ^<Boolean> = (
	^alternative
)
(* Non-evaluating conjunction. *)
public and: alternative <[Boolean]> ^<Boolean> = (
	^alternative value
)
public asString ^<String> = (
	^'true'
)
(* Branching. *)
(* :inlineBytecode: *)
public ifFalse: else <[Y def]> ^<nil | Y> = (
	(* Usually this message is implemented inline by the bytecode compiler, and therefore not subject to lookup. This implementation handles non-inlined cases, such as eventual sends or non-literal arguments. *)
	^nil
)
(* Branching. *)
(* :inlineBytecode: *)
public ifFalse: else <[Y def]> ifTrue: then <[X def]> ^<X | Y> = (
	(* Usually this message is implemented inline by the bytecode compiler, and therefore not subject to lookup. This implementation handles non-inlined cases, such as eventual sends or non-literal arguments. *)
	^then value
)
(* Branching. *)
(* :inlineBytecode: *)
public ifTrue: then <[X def]> ^<X | nil> = (
	(* Usually this message is implemented inline by the bytecode compiler, and therefore not subject to lookup. This implementation handles non-inlined cases, such as eventual sends or non-literal arguments. *)
	^then value
)
(* Branching. *)
(* :inlineBytecode: *)
public ifTrue: then <[X def]> ifFalse: else <[Y def]> ^<X | Y> = (
	(* Usually this message is implemented inline by the bytecode compiler, and therefore not subject to lookup. This implementation handles non-inlined cases, such as eventual sends or non-literal arguments. *)
	^then value
)
(* Negation. *)
public not ^<Boolean> = (
	^false
)
(* Non-evaluating disjunction. *)
public or: alternative <[Boolean]> ^<Boolean> = (
	^true
)
public printString ^<String> = (
	^'true'
)
(* Evaluating disjunction. *)
public | alternative <Boolean> ^<Boolean> = (
	^true
)
) : (
)
(* Defines the behavior of `nil`. *)
(* :exemplar: nil *)
public class UndefinedObject _cannotInstantiate = (
) (
public isNil ^<Boolean> = (
	^true
)
public printString ^<String> = (
	^'nil'
)
) : (
)
(* An array that does not prevent its elements from being garbage collected. *)
(* :exemplar: (WeakArray new: 3) at: 1 put: Object new; yourself *)
public class WeakArray _cannotInstantiate = Collection (
) (
public at: index <Integer> ^<E> = (
	(* :pragma: primitive: 78 *)
	^(ArgumentError value: index) signal
)
public at: index <Integer> put: value <E> ^<E> = (
	(* :pragma: primitive: 79 *)
	^(ArgumentError value: index) signal
)
public copyWith: newElement <E> ^<WeakArray[E]> = (
	|
	newArray = WeakArray new: 1 + self size.
	|
	1 to: self size do:
		[:index | newArray at: index put: (self at: index)].
	newArray at: newArray size put: newElement.
	^newArray
)
public do: action <[:E]> = (
	1 to: self size do: [:index <Integer> | action value: (self at: index)].
)
public isEmpty ^<Boolean> = (
	^0 = self size
)
public isKindOfArray ^<Boolean> = (
	^true
)
public isKindOfWeakArray ^<Boolean> = (
	^true
)
public keysAndValuesDo: action <[:Integer :E]> = (
	1 to: self size do: [:index | action value: index value: (self at: index)].
)
public size ^<Integer> = (
	(* :pragma: primitive: 80 *)
	panic.
)
) : (
public new: size <Integer> ^<WeakArray[E]> = (
	(* :pragma: primitive: 75 *)
	^(ArgumentError value: size) signal
)
)
(* A collection of key/value associations that do not prevent the keys and values from becoming garbage collected.

`nil` is not allowed as a key.

Note this class does not implement Map or Collection because it does not provide enumeration. *)
public class WeakMap = (
|
private table ::= Array new: 256. (* A fairly large initial capacity because the expected usage is one per module. *)
private used ::= 0.
|) (
public at: key <K> ^<V> = (
	| mask index entry |
	nil = key ifTrue: [^nil].
	mask:: table size - 1.
	index:: 1 + ((identityHashOf: key) bitAnd: mask).
	entry:: table at: index.
	[nil = entry] whileFalse:
		[(is: entry key identicalTo: key) ifTrue:
			[^entry value].
		index:: 1 + (index bitAnd: mask).
		entry:: table at: index].
	^nil
)
public at: key <K> put: value <V> ^<V> = (
	| mask index entry |
	nil = key ifTrue: [^invalidKey].

	mask:: table size - 1.
	index:: 1 + ((identityHashOf: key) bitAnd: mask).
	entry:: table at: index.

	[nil = entry] whileFalse:
		[(is: entry key identicalTo: key) ifTrue:
			[(* Update existing entry. *)
			entry value: value.
			^value].
		nil = entry key ifTrue:
			[(* Reuse collected entry. *)
			entry key: key.
			entry value: value.
			^value].
		index:: 1 + (index bitAnd: mask).
		entry:: table at: index].

	(* Create new entry. *)
	entry:: Ephemeron new.
	entry key: key.
	entry value: value.
	table at: index put: entry.
	used:: 1 + used.

	(* If >75% full. *)
	used > ((table size >> 2) * 3) ifTrue: [maybeGrow].

	^value
)
public includesKey: key <K> ^<Boolean> = (
	| mask index entry |
	nil = key ifTrue: [^false].
	mask:: table size - 1.
	index:: 1 + ((identityHashOf: key) bitAnd: mask).
	entry:: table at: index.
	[nil = entry] whileFalse:
		[(is: entry key identicalTo: key) ifTrue:
			[^true].
		index:: 1 + (index bitAnd: mask).
		entry:: table at: index].
	^false
)
public isKindOfWeakMap ^<Boolean> = (
	^true
)
private maybeGrow = (
	| oldTable dead ::= 0. newCapacity newTable mask newUsed ::= 0. |
	oldTable:: table.
	(* Count the number of GC'd entries. If less than half of the table entries are still used, we'll rehash without growing. *)
	1 to: oldTable size do:
		[:index |
		| entry = oldTable at: index. |
		nil = entry ifFalse:
			[nil = entry key ifTrue: [dead:: 1 + dead]]].

	newCapacity:: oldTable size.
	(used - dead) > (newCapacity >> 1) ifTrue:
		[newCapacity:: newCapacity << 1].

	newTable:: Array new: newCapacity.
	mask:: newCapacity - 1.

	(* Count live entries as we rehash instead of using (used - dead) because more entries may become dead due to a GC in the middle of rehashing. *)
	1 to: oldTable size do:
		[:oldIndex |
		| entry = oldTable at: oldIndex. |
		nil = entry ifFalse:
			[nil = entry key ifFalse: [
				| newIndex ::= 1 + ((identityHashOf: entry key) bitAnd: mask). |
				[nil = (newTable at: newIndex)] whileFalse:
					[newIndex:: 1 + (newIndex bitAnd: mask)].
				newTable at: newIndex put: entry.
				newUsed:: 1 + newUsed]]].

	table:: newTable.
	used:: newUsed.
)
public removeKey: key <K> ^<V> = (
	| mask index entry |
	nil = key ifTrue: [^nil].
	mask:: table size - 1.
	index:: 1 + ((identityHashOf: key) bitAnd: mask).
	entry:: table at: index.
	[nil = entry] whileFalse:
		[(is: entry key identicalTo: key) ifTrue:
			[ | oldValue = entry value. |
			 entry key: nil; value: nil.
			 ^oldValue].
		index:: 1 + (index bitAnd: mask).
		entry:: table at: index].
	^nil
)
) : (
)
(* The root object of a complete snapshot. It provides the objects that are known to the VM. *)
public buildObjectStore = (
	^{
		nil.
		false.
		true.
		messageLoop.
		{#+. 1. #-. 1. #*. 1. #//. 1. #\\. 1. #<<. 1. #>>. 1. #&. 1. #|. 1. #<. 1. #>. 1. #<=. 1. #>=. 1. #=. 1. #new. 0. #new:. 1. #at:. 1. #at:put:. 2. #size. 0. #value. 0. #value:. 1. #value:value:. 2. #name. 0. #name:. 1. #add:. 1. #hash. 0. #yourself. 0. #,. 1. #and:. 1. #or:. 1. #not. 0. #basicNew. 0.}.
		#doesNotUnderstand:.
		#nonBooleanReceiver:.
		#cannotReturn:.
		#aboutToReturn:through:.
		#eventualSendTo:selector:arguments:.
		#dispatchMessage:port:.
		#dispatchHandle:status:signals:count:.
		Array.
		ByteArray.
		String.
		Closure.
		Ephemeron.
		Float.
		LargeInteger.
		MediumInteger.
		Message.
		SmallInteger.
		WeakArray.
		Activation.
		Method.
	}
)
private classOf: object = (
	(* :pragma: primitive: 127 *)
	panic.
)
private currentActivation ^<Activation> = (
	(* :pragma: primitive: 164 *)
	panic.
)
private definingActivationOf: closure <Closure> ^<Activation> = (
	(* :pragma: primitive: 148 *)
	panic.
)
private enclosingObjectOf: behavior = (
	^self slotOf: behavior at: 3
)
private enclosingObjectOf: behavior put: value = (
	^self slotOf: behavior at: 3 put: value
)
private formatOf: behavior = (
	^self slotOf: behavior at: 6
)
private formatOf: behavior put: value = (
	^self slotOf: behavior at: 6 put: value
)
public garbageCollect = (
	(* :pragma: primitive: 184 *)
	panic.
)
private identityHashOf: a = (
	(* :pragma: primitive: 136 *)
	panic.
)
private instantiate: klass = (
	(* :pragma: primitive: 140 *)
	panic.
)
private intern: string = (
	| table capacity index reuseIndex symbol |
	nil = symbolTableUsed ifTrue:
		[(* Snapshot starts with a compact array. A hash table would need to be rehashed anyway because every process has a random hash function. *)
		 symbolTableUsed:: symbolTable size.
		 rehashSymbolTable].

	table:: symbolTable.
	capacity:: table size.
	index:: (string hash \\ capacity) + 1.
	[symbol:: table at: index.
	 table = symbol] whileFalse:
		[string = symbol ifTrue: [^symbol].
		 nil = symbol ifTrue: [reuseIndex:: index].
		 index:: (index \\ capacity) + 1].

	setCanonical: string.
	nil = reuseIndex ifFalse: [^table at: reuseIndex put: string].

	table at: index put: string.
	symbolTableUsed:: symbolTableUsed + 1.
	(symbolTableUsed * 4) > (capacity * 3) ifTrue:
		[rehashSymbolTable].
	^string
)
private is: a identicalTo: b = (
	(* :pragma: primitive: 135 *)
	panic.
)
private isCanonical: object = (
	(* :pragma: primitive: 128 *)
	panic.
)
private methodsOf: behavior = (
	^self slotOf: behavior at: 2
)
private methodsOf: behavior put: value = (
	^self slotOf: behavior at: 2 put: value
)
private mixinOf: behavior = (
	^self slotOf: behavior at: 4
)
private mixinOf: behavior put: value = (
	^self slotOf: behavior at: 4 put: value
)
private nameOf: klass = (
	^self slotOf: klass at: 7
)
private nameOf: klass put: value = (
	^self slotOf: klass at: 7 put: value
)
private panic = (
	(* :pragma: primitive: 187 *)
)
print: message = (
	(* :pragma: primitive: 509 *)
)
private rehashSymbolTable = (
	| oldTable dead ::= 0. newCapacity newTable newUsed ::= 0. |
	oldTable:: symbolTable.
	(* Count the number of GC'd entries. If less than half of the table entries are still used, we'll rehash without growing. *)
	1 to: oldTable size do: [:index | nil = (oldTable at: index) ifTrue: [dead:: 1 + dead]].
	newCapacity:: oldTable size.
	(symbolTableUsed - dead) > (newCapacity >> 1) ifTrue:
		[newCapacity:: newCapacity << 1].

	newTable:: WeakArray new: newCapacity.
	1 to: newTable size do: [:index | newTable at: index put: newTable].

	(* Count live entries as we rehash instead of using (used - dead) because more entries may become dead due to a GC in the middle of rehashing. *)
	1 to: oldTable size do:
		[:oldIndex | | symbol newIndex |
		symbol:: oldTable at: oldIndex.
		nil = symbol ifFalse:
			[oldTable = symbol ifFalse:
				[newUsed:: 1 + newUsed.
				 newIndex:: (symbol hash \\ newCapacity) + 1.
				 [newTable = (newTable at: newIndex)] whileFalse:
					[newIndex:: (newIndex \\ newCapacity) + 1].
				 newTable at: newIndex put: symbol]]].

	symbolTable:: newTable.
	symbolTableUsed:: newUsed.
)
private setCanonical: object = (
	(* :pragma: primitive: 129 *)
	panic.
)
private slotOf: object at: index = (
	(* :pragma: primitive: 130 *)
	panic.
)
private slotOf: object at: index put: value = (
	(* :pragma: primitive: 131 *)
	panic.
)
private subclassesOf: klass = (
	^self slotOf: klass at: 8
)
private subclassesOf: klass put: value = (
	^self slotOf: klass at: 8 put: value
)
private superclassOf: behavior = (
	^self slotOf: behavior at: 1
)
private superclassOf: behavior put: value = (
	^self slotOf: behavior at: 1 put: value
)
private thisClassOf: metaclass = (
	^self slotOf: metaclass at: 7
)
private thisClassOf: metaclass put: value = (
	^self slotOf: metaclass at: 7 put: value
)
) : (
)
