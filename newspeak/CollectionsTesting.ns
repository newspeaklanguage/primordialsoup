class CollectionsTesting usingCollections: c minitest: m = (|
private TestContext = m TestContext.

private List = c List.
private Map = c Map.
private Set = c Set.
private OrderedMap = c OrderedMap.
private OrderedSet = c OrderedSet.
|) (
public class CollectionTests = TestContext () (
public testArrayList = (
	| list = List new. |
	assert: list size equals: 0.
	assert: list isEmpty.
	should: [list at: 0] signal: rangeError.
	should: [list at: -1] signal: rangeError.

	list addLast: 10.
	assert: list size equals: 1.
	deny: list isEmpty.
	should: [list at: 0] signal: rangeError.
	assert: (list at: 1) equals: 10.
	should: [list at: 2] signal: rangeError.

	list addFirst: 20.
	assert: list size equals: 2.
	should: [list at: 0] signal: rangeError.
	assert: (list at: 1) equals: 20.
	assert: (list at: 2) equals: 10.
	should: [list at: 3] signal: rangeError.

	list include: 20.
	assert: list size equals: 2.
	should: [list at: 0] signal: rangeError.
	assert: (list at: 1) equals: 20.
	assert: (list at: 2) equals: 10.
	should: [list at: 3] signal: rangeError.

	assert: (list at: 2 put: 30) equals: 30.
	should: [list at: 0 put: nil] signal: rangeError.
	should: [list at: 3 put: nil] signal: rangeError.

	assert: (list includes: 30).
	deny: (list includes: 10).

	assert: list removeLast equals: 30.
	assert: list size equals: 1.
	should: [list at: 0] signal: rangeError.
	assert: (list at: 1) equals: 20.
	should: [list at: 2] signal: rangeError.
)
public testHashMap = (
	| map = Map new. |
	assert: map size equals: 0.
	assert: map isEmpty.
	should: [map at: 'A'] signal: rangeError.

	assert: (map at: 'A' put: 'AA') equals: 'AA'.
	assert: (map at: 'B' put: 'BB') equals: 'BB'.
	assert: (map at: 'C' put: 'CC') equals: 'CC'.
	assert: map size equals: 3.
	deny: map isEmpty.
	assert: (map at: 'A') equals: 'AA'.
	assert: (map at: 'B') equals: 'BB'.
	assert: (map at: 'C') equals: 'CC'.
	should: [map at: 'D'] signal: rangeError.
	assert: (map at: 'D' ifAbsent: ['None']) equals: 'None'.

	deny: (map includesKey: 'D').
	assert: (map at: 'D' ifAbsentPut: ['DD']) equals: 'DD'.
	assert: (map at: 'D' ifAbsentPut: [fail]) equals: 'DD'.
	assert: (map includesKey: 'D').

	assert: (map removeKey: 'B') equals: 'BB'.
	should: [map removeKey: 'B'] signal: rangeError.
	assert: (map removeKey: 'B' ifAbsent: ['None']) equals: 'None'.

	assert: (map at: 'A' put: 'newAA') equals: 'newAA'.
	assert: (map at: 'A') equals: 'newAA'.

	assert: map size equals: 3.
)
public testHashMap2 = (
	| map = Map new. |

	map at: 'A' put: 'newAA'.
	map at: 'C' put: 'CCC'.
	map at: 'D' ifAbsentPut: ['DD'].

	assert: map values isKindOfArray.
	assert: map values size equals: 3.
	assert: map keys size equals: 3.
	assert: map keys isKindOfArray.

	assert: (map includes: 'newAA').
	assert: (map includes: 'CCC').
	assert: (map includes: 'DD').
	deny: (map includes: 'B').

	map do: [:e | assert: [e size > 1]].

	assert: (map detect: [:e | e = 'DD']) equals: 'DD'.
)
public testHashSet = (
	| set = Set new. |
	assert: set size equals: 0.
	assert: set isEmpty.
	should: [set at: 0] signal: rangeError.

	assert: (set add: 2) equals: 2.
	assert: set size equals: 1.
	deny: set isEmpty.

	assert: (set add: 2) equals: 2.
	assert: set size equals: 1.

	set add: 4; include: 6; add: 8.
	set addAll: {1. 2. 3. 4}.
	assert: set size equals: 6.

	assert: (set remove: 3) equals: 3.
	assert: set size equals: 5.

	set removeAllSuchThat: [:e | e \\ 2 = 0].
	assert: set size equals: 1.
)
public testIsKindOfCollection = (
	assert: {} isKindOfCollection.
	assert: (Array new: 0) isKindOfCollection.
	assert: List new isKindOfCollection.
	assert: Map new isKindOfCollection.
	assert: Set new isKindOfCollection.
	deny: nil isKindOfCollection.
	deny: false isKindOfCollection.
	deny: true isKindOfCollection.
	deny: 0 isKindOfCollection.
)
) : (
TEST_CONTEXT = ()
)
public class ListTests = TestContext () (
public testIsKindOfList = (
	deny: {} isKindOfList.
	deny: (Array new: 0) isKindOfList.
	assert: List new isKindOfList.
	deny: Map new isKindOfList.
	deny: OrderedMap new isKindOfList.
	deny: Set new isKindOfList.
	deny: OrderedSet new isKindOfList.
	deny: nil isKindOfList.
	deny: false isKindOfList.
	deny: true isKindOfList.
	deny: 0 isKindOfList.
)
public testListAdd = (
	| list = List new: 0. |
	assert: list size equals: 0.

	list add: 'apple'.
	assert: list size equals: 1.
	assert: (list at: 1) equals: 'apple'.

	list add: 'banana'.
	assert: list size equals: 2.
	assert: (list at: 1) equals: 'apple'.
	assert: (list at: 2) equals: 'banana'.

	list add: 'orange'.
	assert: list size equals: 3.
	assert: (list at: 1) equals: 'apple'.
	assert: (list at: 2) equals: 'banana'.
	assert: (list at: 3) equals: 'orange'.

	list add: 'strawberry'.
	assert: list size equals: 4.
	assert: (list at: 1) equals: 'apple'.
	assert: (list at: 2) equals: 'banana'.
	assert: (list at: 3) equals: 'orange'.
	assert: (list at: 4) equals: 'strawberry'.

	list add: 'watermelon'.
	assert: list size equals: 5.
	assert: (list at: 1) equals: 'apple'.
	assert: (list at: 2) equals: 'banana'.
	assert: (list at: 3) equals: 'orange'.
	assert: (list at: 4) equals: 'strawberry'.
	assert: (list at: 5) equals: 'watermelon'.
)
public testListAddAll = (
	| list = List new: 0. |
	assert: list size equals: 0.

	list addAll: {'apple'. 'banana'}.
	assert: list size equals: 2.
	assert: (list at: 1) equals: 'apple'.
	assert: (list at: 2) equals: 'banana'.

	list addAll: {}.
	assert: list size equals: 2.
	assert: (list at: 1) equals: 'apple'.
	assert: (list at: 2) equals: 'banana'.

	list addAll: {'orange'. 'strawberry'. 'watermelon'}.
	assert: list size equals: 5.
	assert: (list at: 1) equals: 'apple'.
	assert: (list at: 2) equals: 'banana'.
	assert: (list at: 3) equals: 'orange'.
	assert: (list at: 4) equals: 'strawberry'.
	assert: (list at: 5) equals: 'watermelon'.
)
public testListAddFirst = (
	| list = List new: 0. |
	assert: list size equals: 0.

	list addFirst: 'apple'.
	assert: list size equals: 1.
	assert: (list at: 1) equals: 'apple'.

	list addFirst: 'banana'.
	assert: list size equals: 2.
	assert: (list at: 1) equals: 'banana'.
	assert: (list at: 2) equals: 'apple'.

	list addFirst: 'orange'.
	assert: list size equals: 3.
	assert: (list at: 1) equals: 'orange'.
	assert: (list at: 2) equals: 'banana'.
	assert: (list at: 3) equals: 'apple'.

	list addFirst: 'strawberry'.
	assert: list size equals: 4.
	assert: (list at: 1) equals: 'strawberry'.
	assert: (list at: 2) equals: 'orange'.
	assert: (list at: 3) equals: 'banana'.
	assert: (list at: 4) equals: 'apple'.

	list addFirst: 'watermelon'.
	assert: list size equals: 5.
	assert: (list at: 1) equals: 'watermelon'.
	assert: (list at: 2) equals: 'strawberry'.
	assert: (list at: 3) equals: 'orange'.
	assert: (list at: 4) equals: 'banana'.
	assert: (list at: 5) equals: 'apple'.
)
public testListAsArray = (
	| list = List new. array |
	list add: 'blueberry'.
	list add: 'blackberry'.

	array:: list asArray.
	assert: array isKindOfArray.
	assert: array size equals: 2.
	assert: (array at: 1) equals: 'blueberry'.
	assert: (array at: 2) equals: 'blackberry'.

	array at: 1 put: 'cantalope'.
	array at: 2 put: 'watermelon'.
	assert: (list at: 1) equals: 'blueberry'.
	assert: (list at: 2) equals: 'blackberry'.
)
public testListAt = (
	| list empty |
	list:: List new.
	list add: 'apple'.
	list add: 'banana'.

	assert: (list at: 1) equals: 'apple'.
	assert: (list at: 2) equals: 'banana'.
	should: [list at: 0] signal: rangeError.
	should: [list at: 3] signal: rangeError.
	should: [list at: -3] signal: rangeError.
	should: [list at: nil] signal: Error.

	empty:: List new.
	should: [empty at: 1] signal: rangeError.
)
public testListAtPut = (
	| list empty |
	list:: List new.
	list add: 'apple'.
	list add: 'banana'.

	assert: (list at: 1) equals: 'apple'.
	assert: (list at: 2) equals: 'banana'.
	assert: list size equals: 2.

	assert: (list at: 1 put: 'orange') equals: 'orange'.
	assert: (list at: 1) equals: 'orange'.
	assert: (list at: 2) equals: 'banana'.
	assert: list size equals: 2.

	assert: (list at: 2 put: 'kiwi') equals: 'kiwi'.
	assert: (list at: 1) equals: 'orange'.
	assert: (list at: 2) equals: 'kiwi'.
	assert: list size equals: 2.

	should: [list at: 0 put: 'pineapple'] signal: rangeError.
	should: [list at: 3 put: 'pineapple'] signal: rangeError.
	should: [list at: -3 put: 'pineapple'] signal: rangeError.
	should: [list at: nil put: 'pineapple'] signal: Error.

	empty:: List new.
	should: [empty at: 1 put: 'orange'] signal: Error.
)
public testListConcatenation = (
	|
	a = List new.
	b = List new.
	c
	|
	a add: 'apple'.
	b add: 'banana'.
	b add: 'orange'.
	b add: 'strawberry'.
	c:: a, b.

	assert: c size equals: 4.
	assert: (c at: 1) equals: 'apple'.
	assert: (c at: 2) equals: 'banana'.
	assert: (c at: 3) equals: 'orange'.
	assert: (c at: 4) equals: 'strawberry'.

	c add: 'pineapple'.
	assert: c size equals: 5.
	assert: (c at: 5) equals: 'pineapple'.

	assert: a size equals: 1.
	assert: (a at: 1) equals: 'apple'.
	assert: b size equals: 3.
	assert: (b at: 1) equals: 'banana'.
	assert: (b at: 2) equals: 'orange'.
	assert: (b at: 3) equals: 'strawberry'.
)
public testListCopyFromTo = (
	| list result |
	list:: List withAll: {10. 20. 30. 40. 50. 60. 70}.

	result:: list copyFrom: 1 to: 7.
	deny: result isKindOfArray.
	assert: result isKindOfList.
	assertList: result equals: {10. 20. 30. 40. 50. 60. 70}.
	result at: 1 put: nil.
	result at: 7 put: nil.
	assertList: list equals: {10. 20. 30. 40. 50. 60. 70}.

	result:: list copyFrom: 1 to: 0.
	deny: result isKindOfArray.
	assert: result isKindOfList.
	assertList: result equals: {}.

	result:: list copyFrom: 1 to: 1.
	deny: result isKindOfArray.
	assert: result isKindOfList.
	assertList: result equals: {10}.

	result:: list copyFrom: 2 to: 6.
	deny: result isKindOfArray.
	assert: result isKindOfList.
	assertList: result equals: {20. 30. 40. 50. 60}.

	result:: list copyFrom: 7 to: 7.
	deny: result isKindOfArray.
	assert: result isKindOfList.
	assertList: result equals: {70}.

	should: [list copyFrom: -1 to: 1] signal: Error.
	should: [list copyFrom: 0 to: 1] signal: Error.
	should: [list copyFrom: 7 to: 8] signal: Error.
)
public testListDo = (
	| list count |
	list:: List new.
	list add: 'apple'.
	list add: 'banana'.
	list removeLast.
	count:: 0.
	list do:
		[:value |
		 assert: value equals: 'apple'.
		 count:: count + 1].
	assert: count equals: 1.
)
public testListEnumeration = (
	| list evens odds sum |
	list:: List withAll: {1. 2. 3. 4. 5. 6. 7. 8. 9}.

	evens:: list select: [:e | e \\ 2 = 0].
	assert: evens size equals: 4.

	odds:: list reject: [:e | e \\ 2 = 0].
	assert: odds size equals: 5.

	sum:: list inject: 0 into: [:a :b | a + b].
	assert: sum equals: 45.

	sum:: list reduce: [:a :b | a + b] ifEmpty: [fail].
	assert: sum equals: 45.

	sum:: list reduce: [:a :b | a + b].
	assert: sum equals: 45.

	assert: (list anySatisfy: [:e | e > 0]).
	assert: (list allSatisfy: [:e | e > 0]).
	deny: (list noneSatisfy: [:e | e > 0]).

	deny: (list anySatisfy: [:e | e < 0]).
	deny: (list allSatisfy: [:e | e < 0]).
	assert: (list noneSatisfy: [:e | e < 0]).

	assert: (list detect: [:e | e > 5]) equals: 6.
	assert: (list detect: [:e | e > 55] ifNone: ['None']) equals: 'None'.
)
public testListEnumerationEmpty = (
	| list evens odds sum |
	list:: List new.

	evens:: list select: [:e | e \\ 2 = 0].
	assert: evens size equals: 0.

	odds:: list reject: [:e | e \\ 2 = 0].
	assert: odds size equals: 0.

	sum:: list inject: 0 into: [:a :b | a + b].
	assert: sum equals: 0.

	sum:: list reduce: [:a :b | a + b] ifEmpty: ['Empty'].
	assert: sum equals: 'Empty'.

	should: [list reduce: [:a :b | a + b]] signal: Error.

	deny: (list anySatisfy: [:e | fail]).
	assert: (list allSatisfy: [:e | fail]).
	assert: (list noneSatisfy: [:e | fail]).

	should: [list detect: [:e | e > 5]] signal: Error.
	assert: (list detect: [:e | e > 55] ifNone: ['None']) equals: 'None'.
)
public testListEqualityIsIdentity = (
	|
	empty1 = List new.
	empty2 = List new.
	simple1 = List new.
	simple2 = List new.
	cycle1 = List new.
	cycle2 = List new.
	|
	simple1 add: 'strawberry'.
	simple2 add: 'strawberry'.
	cycle1 add: cycle1.
	cycle2 add: cycle2.

	assert: empty1 equals: empty1.
	assert: empty2 equals: empty2.
	deny: empty1 equals: empty2.
	deny: empty2 equals: empty1.

	assert: simple1 equals: simple1.
	assert: simple2 equals: simple2.
	deny: simple1 equals: simple2.
	deny: simple2 equals: simple1.

	assert: cycle1 equals: cycle1.
	assert: cycle2 equals: cycle2.
	deny: cycle1 equals: cycle2.
	deny: cycle2 equals: cycle1.
)
public testListFirstLast = (
	| list = List new. empty = List new. |
	list add: 'apple'.
	list add: 'banana'.

	assert: (list first) equals: 'apple'.
	assert: (list last) equals: 'banana'.

	should: [empty first] signal: Error.
	should: [empty last] signal: Error.
)
public testListFloatIndex = (
	| list = List new. |
	list add: 'apple'.

	should: [list at: 1 asFloat] signal: Error.
	should: [list at: 1 asFloat put: 'banana'] signal: Error.
)
public testListIndexOf = (
	| list = List new. empty = List new. |
	list add: 42.
	list add: nil.
	list add: 'apple'.
	list add: 'banana'.
	list add: 'apple'.
	list add: 'banana'.

	assert: (list indexOf: 42) equals: 1.
	assert: (list indexOf: nil) equals: 2.
	assert: (list indexOf: 'apple') equals: 3.
	assert: (list indexOf: 'banana') equals: 4.
	assert: (list indexOf: 'noSuchElement') equals: 0.

	assert: (empty indexOf: 'noSuchElement') equals: 0.
)
public testListIsEmpty = (
	| list |
	assert: (List new: 0) isEmpty.
	assert: (List new: 16) isEmpty.

	list:: List new.
	assert: list isEmpty.
	list add: #element.
	deny: list isEmpty.
	list removeLast.
	assert: list isEmpty.
)
public testListKeysAndValuesDo = (
	| list count |
	list:: List new.
	list add: 'apple'.
	list add: 'banana'.
	list removeLast.
	count:: 0.
	list keysAndValuesDo:
		[:key :value |
		 assert: key equals: 1.
		 assert: value equals: 'apple'.
		 count:: count + 1].
	assert: count equals: 1.
)
public testListNew = (
	assert: (List new) size equals: 0.
	assert: (List new: 0) size equals: 0.
	assert: (List new: 16) size equals: 0.

	should: [List new: -1] signal: Error.
	should: [List new: '10'] signal: Error.
	should: [List new: nil] signal: Error.
)
public testListRemove = (
	| list = List new: 0. |
	list add: 'apple'.
	list add: 'banana'.
	list add: 'orange'.
	list add: 'strawberry'.
	list add: 'watermelon'.
	assert: list size equals: 5.

	assert: (list remove: 'orange') equals: 'orange'.
	assert: list size equals: 4.
	assert: (list at: 1) equals: 'apple'.
	assert: (list at: 2) equals: 'banana'.
	assert: (list at: 3) equals: 'strawberry'.
	assert: (list at: 4) equals: 'watermelon'.

	should: [list remove: 'orange'] signal: Error.
	assert: (list remove: 'orange' ifAbsent: ['missing']) equals: 'missing'.

	assert: (list remove: 'apple') equals: 'apple'.
	assert: list size equals: 3.
	assert: (list at: 1) equals: 'banana'.
	assert: (list at: 2) equals: 'strawberry'.
	assert: (list at: 3) equals: 'watermelon'.

	assert: (list remove: 'watermelon') equals: 'watermelon'.
	assert: list size equals: 2.
	assert: (list at: 1) equals: 'banana'.
	assert: (list at: 2) equals: 'strawberry'.

	assert: (list remove: 'banana') equals: 'banana'.
	assert: list size equals: 1.
	assert: (list at: 1) equals: 'strawberry'.

	assert: (list remove: 'strawberry') equals: 'strawberry'.
	assert: list size equals: 0.
)
public testListRemoveAll = (
	| list = List new: 0. |
	list add: 'apple'.
	list add: 'banana'.
	list add: 'orange'.
	list add: 'strawberry'.
	list add: 'watermelon'.
	assert: list size equals: 5.

	list removeAll.
	assert: list size equals: 0.
	should: [list at: 1] signal: rangeError.
	list removeAll.
	assert: list size equals: 0.

	list add: 'apricot'.
	list add: 'cherry'.
	list add: 'mango'.
	list add: 'nectarine'.
	list add: 'lemon'.
	list add: 'lime'.
	list add: 'peach'.
	list add: 'plum'.
	assert: list size equals: 8.
	assert: (list at: 1) equals: 'apricot'.
	assert: (list at: 2) equals: 'cherry'.
	assert: (list at: 3) equals: 'mango'.
	assert: (list at: 4) equals: 'nectarine'.
	assert: (list at: 5) equals: 'lemon'.
	assert: (list at: 6) equals: 'lime'.
	assert: (list at: 7) equals: 'peach'.
	assert: (list at: 8) equals: 'plum'.

	list removeAll.
	assert: list size equals: 0.
)
public testListRemoveAllSuchThat = (
	| list = List new: 0. |
	list add: 'apple'.
	list add: 'banana'.
	list add: 'orange'.
	list add: 'strawberry'.
	list add: 'watermelon'.
	assert: list size equals: 5.

	list removeAllSuchThat: [:fruit | (fruit indexOf: "n") > 0].
	assert: list size equals: 2.
	assert: (list at: 1) equals: 'apple'.
	assert: (list at: 2) equals: 'strawberry'.
)
public testListRemoveFirst = (
	| list = List new: 0. |
	list add: 'apple'.
	list add: 'banana'.
	list add: 'orange'.
	list add: 'strawberry'.
	list add: 'watermelon'.
	assert: list size equals: 5.

	assert: list removeFirst equals: 'apple'.
	assert: list size equals: 4.
	assert: (list at: 1) equals: 'banana'.
	assert: (list at: 2) equals: 'orange'.
	assert: (list at: 3) equals: 'strawberry'.
	assert: (list at: 4) equals: 'watermelon'.

	assert: list removeFirst equals: 'banana'.
	assert: list size equals: 3.
	assert: (list at: 1) equals: 'orange'.
	assert: (list at: 2) equals: 'strawberry'.
	assert: (list at: 3) equals: 'watermelon'.

	assert: list removeFirst equals: 'orange'.
	assert: list size equals: 2.
	assert: (list at: 1) equals: 'strawberry'.
	assert: (list at: 2) equals: 'watermelon'.

	assert: list removeFirst equals: 'strawberry'.
	assert: list size equals: 1.
	assert: (list at: 1) equals: 'watermelon'.

	assert: list removeFirst equals: 'watermelon'.
	assert: list size equals: 0.

	should: [list removeFirst] signal: Error.
)
public testListRemoveLast = (
	| list = List new: 0. |
	list add: 'apple'.
	list add: 'banana'.
	list add: 'orange'.
	list add: 'strawberry'.
	list add: 'watermelon'.
	assert: list size equals: 5.

	assert: list removeLast equals: 'watermelon'.
	assert: list size equals: 4.
	assert: (list at: 1) equals: 'apple'.
	assert: (list at: 2) equals: 'banana'.
	assert: (list at: 3) equals: 'orange'.
	assert: (list at: 4) equals: 'strawberry'.

	assert: list removeLast equals: 'strawberry'.
	assert: list size equals: 3.
	assert: (list at: 1) equals: 'apple'.
	assert: (list at: 2) equals: 'banana'.
	assert: (list at: 3) equals: 'orange'.

	assert: list removeLast equals: 'orange'.
	assert: list size equals: 2.
	assert: (list at: 1) equals: 'apple'.
	assert: (list at: 2) equals: 'banana'.

	assert: list removeLast equals: 'banana'.
	assert: list size equals: 1.
	assert: (list at: 1) equals: 'apple'.

	assert: list removeLast equals: 'apple'.
	assert: list size equals: 0.

	should: [list removeLast] signal: Error.
)
public testListSort = (
	| list |
	list:: List withAll: {12. 15. 3. 5. 10. 6. 8. 1. 13. 11. 16. 4. 14. 9. 2. 7}.
	assert: list size equals: 16.
	list sort: [:a :b | a < b].
	assert: list size equals: 16.
	1 to: 16 do: [:index | assert: (list at: index) equals: index].

	list:: List withAll: {12. 8. 9. 7. 2. 10. 4. 6. 5. 3. 13. 15. 14. 1. 11}.
	assert: list size equals: 15.
	list sort: [:a :b | a < b].
	assert: list size equals: 15.
	1 to: 15 do: [:index | assert: (list at: index) equals: index].

	list:: List withAll: {10. 12. 2. 11. 14. 4. 13. 3. 9. 8. 7. 5. 6. 1}.
	assert: list size equals: 14.
	list sort: [:a :b | a < b].
	assert: list size equals: 14.
	1 to: 14 do: [:index | assert: (list at: index) equals: index].

	list:: List withAll: {12. 6. 10. 5. 7. 9. 2. 4. 1. 11. 3. 8. 13}.
	assert: list size equals: 13.
	list sort: [:a :b | a < b].
	assert: list size equals: 13.
	1 to: 13 do: [:index | assert: (list at: index) equals: index].
)
public testListSortEmpty = (
	| list |
	list:: List new.
	assert: list size equals: 0.
	list sort: [:a :b | a < b].
	assert: list size equals: 0.
)
public testListWithAll = (
	| array bytearray list result |
	array:: Array new: 2.
	array at: 1 put: 'A'.
	array at: 2 put: 'B'.
	result:: List withAll: array.
	assert: result size equals: 2.
	assert: (result at: 1) equals: 'A'.
	assert: (result at: 2) equals: 'B'.

	bytearray:: ByteArray new: 2.
	bytearray at: 1 put: 67.
	bytearray at: 2 put: 68.
	result:: List withAll: bytearray.
	assert: result size equals: 2.
	assert: (result at: 1) equals: 67.
	assert: (result at: 2) equals: 68.

	result:: List withAll: 'EF'.
	assert: result size equals: 2.
	assert: (result at: 1) equals: 69.
	assert: (result at: 2) equals: 70.

	list:: List new.
	list add: 'G'.
	list add: 'H'.
	result:: List withAll: list.
	assert: result size equals: 2.
	assert: (result at: 1) equals: 'G'.
	assert: (result at: 2) equals: 'H'.

	should: [List withAll: -1] signal: Error.
	should: [List withAll: 16r110000] signal: Error.
	should: [List withAll: nil] signal: Error.
	should: [List withAll: 122 asFloat] signal: Error.
)
) : (
TEST_CONTEXT = ()
)
public class MapTests = TestContext () (
public testIsKindOfMap = (
	deny: {} isKindOfMap.
	deny: (Array new: 0) isKindOfMap.
	deny: List new isKindOfMap.
	assert: Map new isKindOfMap.
	assert: OrderedMap new isKindOfMap.
	deny: Set new isKindOfMap.
	deny: OrderedSet new isKindOfMap.
	deny: nil isKindOfMap.
	deny: false isKindOfMap.
	deny: true isKindOfMap.
	deny: 0 isKindOfMap.
)
public testMapAddAll = (
	| source map |
	source:: Map new.
	source at: 'red' put: 'rouge'.
	source at: 'green' put: 'vert'.
	source at: 'blue' put: 'bleu'.

	map:: Map new.
	map at: 'yellow' put: 'jaune'.

	map addAll: source.
	assert: map size equals: 4.
	assert: (map at: 'red') equals: 'rouge'.
	assert: (map at: 'blue') equals: 'bleu'.
	assert: (map at: 'green') equals: 'vert'.
	assert: (map at: 'yellow') equals: 'jaune'.

	map addAll: {true}.
	assert: map size equals: 5.
	assert: (map at: 1) equals: true.
)
public testMapAtIfAbsentPut = (
	| map |
	map:: Map new.
	map at: 'red' ifAbsentPut: ['rouge'].
	map at: 'red' ifAbsentPut: ['bleu'].
	assert: map size equals: 1.
	assert: (map at: 'red') equals: 'rouge'.
)
public testMapCollect = (
	| map result |
	map:: Map new.
	map at: 'red' put: 'rouge'.
	map at: 'orange' put: 'orange'.
	map at: 'yellow' put: 'jaune'.
	map at: 'green' put: 'vert'.
	map at: 'blue' put: 'bleu'.
	map at: 'purple' put: 'violet'.
	map at: 'white' put: 'blanc'.
	map at: 'gray' put: 'gris'.
	map at: 'black' put: 'noir'.

	result:: map collect: [:each | each size].
	assert: result size equals: 9.
	assert: (result at: 'red') equals: 5.
	assert: (result at: 'orange') equals: 6.
	assert: (result at: 'yellow') equals: 5.
	assert: (result at: 'green') equals: 4.
	assert: (result at: 'blue') equals: 4.
	assert: (result at: 'purple') equals: 6.
	assert: (result at: 'white') equals: 5.
	assert: (result at: 'gray') equals: 4.
	assert: (result at: 'black') equals: 4.
)
public testMapDo = (
	| map count |
	map:: Map new.
	map at: 'red' put: 'rouge'.
	map at: 'blue' put: 'bleu'.
	map removeKey: 'blue'.
	count:: 0.
	map do:
		[:value |
		 assert: value equals: 'rouge'.
		 count:: count + 1].
	assert: count equals: 1.
)
public testMapIsEmpty = (
	| map |
	assert: (Map new: 0) isEmpty.
	assert: (Map new: 16) isEmpty.

	map:: Map new.
	assert: map isEmpty.
	map at: #key put: #value.
	deny: map isEmpty.
	map removeKey: #key.
	assert: map isEmpty.
)
public testMapKeysAndValues = (
	| map keys values |
	map:: Map new.
	map at: 'red' put: 'rouge'.
	map at: 'orange' put: 'orange'.
	map at: 'yellow' put: 'jaune'.
	map at: 'green' put: 'vert'.
	map at: 'blue' put: 'bleu'.
	map at: 'purple' put: 'violet'.
	map at: 'white' put: 'blanc'.
	map at: 'gray' put: 'gris'.
	map at: 'black' put: 'noir'.

	keys:: map keys.
	assert: keys isKindOfArray.
	assert: keys size equals: 9.
	assert: (keys includes: 'red').
	assert: (keys includes: 'orange').
	assert: (keys includes: 'yellow').
	assert: (keys includes: 'green').
	assert: (keys includes: 'blue').
	assert: (keys includes: 'purple').
	assert: (keys includes: 'white').
	assert: (keys includes: 'gray').
	assert: (keys includes: 'black').

	values:: map values.
	assert: values isKindOfArray.
	assert: values size equals: 9.
	assert: (values includes: 'rouge').
	assert: (values includes: 'orange').
	assert: (values includes: 'jaune').
	assert: (values includes: 'vert').
	assert: (values includes: 'bleu').
	assert: (values includes: 'violet').
	assert: (values includes: 'blanc').
	assert: (values includes: 'gris').
	assert: (values includes: 'noir').

	(* Keys and values must have a consistent order. *)
	assert: (keys indexOf: 'red') equals: (values indexOf: 'rouge').
	assert: (keys indexOf: 'orange') equals: (values indexOf: 'orange').
	assert: (keys indexOf: 'yellow') equals: (values indexOf: 'jaune').
	assert: (keys indexOf: 'green') equals: (values indexOf: 'vert').
	assert: (keys indexOf: 'blue') equals: (values indexOf: 'bleu').
	assert: (keys indexOf: 'purple') equals: (values indexOf: 'violet').
	assert: (keys indexOf: 'white') equals: (values indexOf: 'blanc').
	assert: (keys indexOf: 'gray') equals: (values indexOf: 'gris').
	assert: (keys indexOf: 'black') equals: (values indexOf: 'noir').
)
public testMapKeysAndValuesDo = (
	| map count |
	map:: Map new.
	map at: 'red' put: 'rouge'.
	map at: 'blue' put: 'bleu'.
	map removeKey: 'blue'.
	count:: 0.
	map keysAndValuesDo:
		[:key :value |
		 assert: key equals: 'red'.
		 assert: value equals: 'rouge'.
		 count:: count + 1].
	assert: count equals: 1.
)
public testMapLowCapacity = (
	(* Regression test against naively taking the capacity hint, which can break the invariant of having at least one free slot. *)
	0 to: 3 do:
		[:capacityHint | | map |
		 map:: Map new: capacityHint.
		 map at: 'roses' put: 'red'.
		 map at: 'violets' put: 'blue'.
		 assert: map size equals: 2.
		 assert: (map at: 'roses') equals: 'red'.
		 assert: (map at: 'violets') equals: 'blue'].
)
public testMapNew = (
	assert: (Map new) size equals: 0.
	assert: (Map new: 0) size equals: 0.
	assert: (Map new: 16) size equals: 0.

	should: [Map new: -1] signal: Error.
	should: [Map new: '10'] signal: Error.
	should: [Map new: nil] signal: Error.
)
public testMapNilKey = (
	| map = Map new. |
	assert: (map at: nil put: 'pear') equals: 'pear'.
	assert: map size equals: 1.
	assert: (map includesKey: nil).
	assert: (map at: nil) equals: 'pear'.

	(* Try to trigger growth/rehashing. *)
	assert: (map at: 1 put: 'apricot') equals: 'apricot'.
	assert: (map at: 2 put: 'cherry') equals: 'cherry'.
	assert: (map at: 3 put: 'mango') equals: 'mango'.
	assert: (map at: 4 put: 'nectarine') equals: 'nectarine'.
	assert: (map at: 5 put: 'lemon') equals: 'lemon'.
	assert: (map at: 6 put: 'lime') equals: 'lime'.
	assert: (map at: 7 put: 'peach') equals: 'peach'.
	assert: (map at: 8 put: 'plum') equals: 'plum'.

	assert: map size equals: 9.
	assert: (map includesKey: nil).
	assert: (map at: nil) equals: 'pear'.

	assert: (map at: 1) equals: 'apricot'.
	assert: (map at: 2) equals: 'cherry'.
	assert: (map at: 3) equals: 'mango'.
	assert: (map at: 4) equals: 'nectarine'.
	assert: (map at: 5) equals: 'lemon'.
	assert: (map at: 6) equals: 'lime'.
	assert: (map at: 7) equals: 'peach'.
	assert: (map at: 8) equals: 'plum'.

	assert: (map removeKey: nil) equals: 'pear'.
	assert: map size equals: 8.
	deny: (map includesKey: nil).
	assert: (map at: nil put: 'pineapple') equals: 'pineapple'.
	assert: map size equals: 9.
	assert: (map includesKey: nil).
	assert: (map at: nil) equals: 'pineapple'.
)
public testMapReject = (
	| map result |
	map:: Map new.
	map at: 'red' put: 'rouge'.
	map at: 'orange' put: 'orange'.
	map at: 'yellow' put: 'jaune'.
	map at: 'green' put: 'vert'.
	map at: 'blue' put: 'bleu'.
	map at: 'purple' put: 'violet'.
	map at: 'white' put: 'blanc'.
	map at: 'gray' put: 'gris'.
	map at: 'black' put: 'noir'.

	result:: map reject: [:each | each size > 4].
	assert: result size equals: 4.
	assert: (result at: 'green') equals: 'vert'.
	assert: (result at: 'blue') equals: 'bleu'.
	assert: (result at: 'gray') equals: 'gris'.
	assert: (result at: 'black') equals: 'noir'.
)
public testMapRemoveAll = (
	| map = Map new: 0. |
	map at: 'apple' put: 'elppa'.
	map at: 'banana' put: 'ananab'.
	map at: 'orange' put: 'egnaro'.
	map at: 'strawberry' put: 'yrrebwarts'.
	map at: 'watermelon' put: 'nolemretaw'.
	assert: map size equals: 5.

	map removeAll.
	assert: map size equals: 0.
	map removeAll.
	assert: map size equals: 0.

	map at: 'apricot' put: 'tocirpa'.
	map at: 'cherry' put: 'yrrehc'.
	map at: 'mango' put: 'ognam'.
	map at: 'nectarine' put: 'eniratcen'.
	map at: 'lemon' put: 'nomel'.
	map at: 'lime' put: 'emil'.
	map at: 'peach' put: 'hcaep'.
	map at: 'plum' put: 'mulp'.
	assert: map size equals: 8.
	assert: (map at: 'apricot') equals: 'tocirpa'.
	assert: (map at: 'cherry') equals: 'yrrehc'.
	assert: (map at: 'mango') equals: 'ognam'.
	assert: (map at: 'nectarine') equals: 'eniratcen'.
	assert: (map at: 'lemon') equals: 'nomel'.
	assert: (map at: 'lime') equals: 'emil'.
	assert: (map at: 'peach') equals: 'hcaep'.
	assert: (map at: 'plum') equals: 'mulp'.

	map removeAll.
	assert: map size equals: 0.
)
public testMapScalingContiguousHashes = (
	(* Test will be noticeably slow if implementation is quadratic *)
	| n map |
	n:: 10000.
	map:: Map new.
	1 to: n do: [:i | map at: i put: i * 2].
	assert: map size equals: n.
	1 to: n do: [:i | assert: (map at: i) equals: i * 2].

	map:: Map new.
	n to: 1 by: -1 do: [:i | map at: i put: i * 2].
	assert: map size equals: n.
	n to: 1 by: -1 do: [:i | assert: (map at: i) equals: i * 2].
)
public testMapSelect = (
	| map result |
	map:: Map new.
	map at: 'red' put: 'rouge'.
	map at: 'orange' put: 'orange'.
	map at: 'yellow' put: 'jaune'.
	map at: 'green' put: 'vert'.
	map at: 'blue' put: 'bleu'.
	map at: 'purple' put: 'violet'.
	map at: 'white' put: 'blanc'.
	map at: 'gray' put: 'gris'.
	map at: 'black' put: 'noir'.

	result:: map select: [:each | each size > 4].
	assert: result size equals: 5.
	assert: (result at: 'red') equals: 'rouge'.
	assert: (result at: 'orange') equals: 'orange'.
	assert: (result at: 'yellow') equals: 'jaune'.
	assert: (result at: 'purple') equals: 'violet'.
	assert: (result at: 'white') equals: 'blanc'.
)
public testMapSelfKey = (
	| map = Map new. |
	assert: (map at: map put: 'pear') equals: 'pear'.
	assert: map size equals: 1.
	assert: (map includesKey: map).
	assert: (map at: map) equals: 'pear'.

	(* Try to trigger growth/rehashing. *)
	assert: (map at: 1 put: 'apricot') equals: 'apricot'.
	assert: (map at: 2 put: 'cherry') equals: 'cherry'.
	assert: (map at: 3 put: 'mango') equals: 'mango'.
	assert: (map at: 4 put: 'nectarine') equals: 'nectarine'.
	assert: (map at: 5 put: 'lemon') equals: 'lemon'.
	assert: (map at: 6 put: 'lime') equals: 'lime'.
	assert: (map at: 7 put: 'peach') equals: 'peach'.
	assert: (map at: 8 put: 'plum') equals: 'plum'.

	assert: map size equals: 9.
	assert: (map includesKey: map).
	assert: (map at: map) equals: 'pear'.

	assert: (map at: 1) equals: 'apricot'.
	assert: (map at: 2) equals: 'cherry'.
	assert: (map at: 3) equals: 'mango'.
	assert: (map at: 4) equals: 'nectarine'.
	assert: (map at: 5) equals: 'lemon'.
	assert: (map at: 6) equals: 'lime'.
	assert: (map at: 7) equals: 'peach'.
	assert: (map at: 8) equals: 'plum'.

	assert: (map removeKey: map) equals: 'pear'.
	assert: map size equals: 8.
	deny: (map includesKey: map).
	assert: (map at: map put: 'pineapple') equals: 'pineapple'.
	assert: map size equals: 9.
	assert: (map includesKey: map).
	assert: (map at: map) equals: 'pineapple'.
)
public testMapUpdates = (
	| map result |
	map:: Map new.
	map at: 'red' put: 'red'.
	map at: 'orange' put: 'orange'.
	map at: 'yellow' put: 'yellow'.
	map at: 'green' put: 'green'.
	map at: 'blue' put: 'blue'.
	map at: 'purple' put: 'purple'.
	map at: 'white' put: 'white'.
	map at: 'gray' put: 'gray'.
	map at: 'black' put: 'black'.

	map at: 'red' put: 'rouge'.
	map at: 'orange' put: 'orange'.
	map at: 'yellow' put: 'jaune'.
	map at: 'green' put: 'vert'.
	map at: 'blue' put: 'bleu'.
	map at: 'purple' put: 'violet'.
	map at: 'white' put: 'blanc'.
	map at: 'gray' put: 'gris'.
	map at: 'black' put: 'noir'.

	assert: map size equals: 9.
	assert: (map at: 'red') equals: 'rouge'.
	assert: (map at: 'orange') equals: 'orange'.
	assert: (map at: 'yellow') equals: 'jaune'.
	assert: (map at: 'green') equals: 'vert'.
	assert: (map at: 'blue') equals: 'bleu'.
	assert: (map at: 'purple') equals: 'violet'.
	assert: (map at: 'white') equals: 'blanc'.
	assert: (map at: 'gray') equals: 'gris'.
	assert: (map at: 'black') equals: 'noir'.
)
public testMapWithAll = (
	| source map |
	source:: Map new.
	source at: 'red' put: 'rouge'.
	source at: 'green' put: 'vert'.
	source at: 'blue' put: 'bleu'.

	map:: Map withAll: source.
	map at: 'yellow' put: 'jaune'.

	map addAll: source.
	assert: map size equals: 4.
	assert: (map at: 'red') equals: 'rouge'.
	assert: (map at: 'blue') equals: 'bleu'.
	assert: (map at: 'green') equals: 'vert'.
	assert: (map at: 'yellow') equals: 'jaune'.

	map addAll: {true}.
	assert: map size equals: 5.
	assert: (map at: 1) equals: true.
)
) : (
TEST_CONTEXT = ()
)
public class OrderedMapTests = TestContext () (
public testIsKindOfOrderedMap = (
	deny: {} isKindOfOrderedMap.
	deny: (Array new: 0) isKindOfOrderedMap.
	deny: List new isKindOfOrderedMap.
	deny: Map new isKindOfOrderedMap.
	assert: OrderedMap new isKindOfOrderedMap.
	deny: Set new isKindOfOrderedMap.
	deny: OrderedSet new isKindOfOrderedMap.
	deny: nil isKindOfOrderedMap.
	deny: false isKindOfOrderedMap.
	deny: true isKindOfOrderedMap.
	deny: 0 isKindOfOrderedMap.
)
public testOrderedMapAddAll = (
	| source map keys |
	source:: OrderedMap new.
	source at: 'red' put: 'rouge'.
	source at: 'green' put: 'vert'.
	source at: 'blue' put: 'bleu'.

	map:: OrderedMap new.
	map at: 'yellow' put: 'jaune'.

	map addAll: source.
	assert: map size equals: 4.
	assert: (map at: 'red') equals: 'rouge'.
	assert: (map at: 'blue') equals: 'bleu'.
	assert: (map at: 'green') equals: 'vert'.
	assert: (map at: 'yellow') equals: 'jaune'.

	map addAll: {true}.
	assert: map size equals: 5.
	assert: (map at: 1) equals: true.

	keys:: map keys.
	assert: (keys at: 1) equals: 'yellow'.
	assert: (keys at: 2) equals: 'red'.
	assert: (keys at: 3) equals: 'green'.
	assert: (keys at: 4) equals: 'blue'.
	assert: (keys at: 5) equals: 1.
)
public testOrderedMapAtIfAbsentPut = (
	| map |
	map:: OrderedMap new.
	map at: 'red' ifAbsentPut: ['rouge'].
	map at: 'red' ifAbsentPut: ['bleu'].
	assert: map size equals: 1.
	assert: (map at: 'red') equals: 'rouge'.
)
public testOrderedMapCollect = (
	| map result |
	map:: OrderedMap new.
	map at: 'red' put: 'rouge'.
	map at: 'orange' put: 'orange'.
	map at: 'yellow' put: 'jaune'.
	map at: 'green' put: 'vert'.
	map at: 'blue' put: 'bleu'.
	map at: 'purple' put: 'violet'.
	map at: 'white' put: 'blanc'.
	map at: 'gray' put: 'gris'.
	map at: 'black' put: 'noir'.

	result:: map collect: [:each | each size].
	assert: result isKindOfOrderedMap.
	assert: result size equals: 9.
	assert: (result at: 'red') equals: 5.
	assert: (result at: 'orange') equals: 6.
	assert: (result at: 'yellow') equals: 5.
	assert: (result at: 'green') equals: 4.
	assert: (result at: 'blue') equals: 4.
	assert: (result at: 'purple') equals: 6.
	assert: (result at: 'white') equals: 5.
	assert: (result at: 'gray') equals: 4.
	assert: (result at: 'black') equals: 4.
)
public testOrderedMapDo = (
	| map count |
	map:: OrderedMap new.
	map at: 'red' put: 'rouge'.
	map at: 'blue' put: 'bleu'.
	map removeKey: 'blue'.
	count:: 0.
	map do:
		[:value |
		 assert: value equals: 'rouge'.
		 count:: count + 1].
	assert: count equals: 1.
)
public testOrderedMapIsEmpty = (
	| map |
	assert: (OrderedMap new: 0) isEmpty.
	assert: (OrderedMap new: 16) isEmpty.

	map:: OrderedMap new.
	assert: map isEmpty.
	map at: #key put: #value.
	deny: map isEmpty.
	map removeKey: #key.
	assert: map isEmpty.
)
public testOrderedMapKeysAndValues = (
	| map keys values |
	map:: OrderedMap new.
	map at: 'red' put: 'rouge'.
	map at: 'orange' put: 'orange'.
	map at: 'yellow' put: 'jaune'.
	map at: 'green' put: 'vert'.
	map at: 'blue' put: 'bleu'.
	map at: 'purple' put: 'violet'.
	map at: 'white' put: 'blanc'.
	map at: 'gray' put: 'gris'.
	map at: 'black' put: 'noir'.

	keys:: map keys.
	assert: keys isKindOfArray.
	assert: keys size equals: 9.
	assert: (keys at: 1) equals: 'red'.
	assert: (keys at: 2) equals: 'orange'.
	assert: (keys at: 3) equals: 'yellow'.
	assert: (keys at: 4) equals: 'green'.
	assert: (keys at: 5) equals: 'blue'.
	assert: (keys at: 6) equals: 'purple'.
	assert: (keys at: 7) equals: 'white'.
	assert: (keys at: 8) equals: 'gray'.
	assert: (keys at: 9) equals: 'black'.

	values:: map values.
	assert: values isKindOfArray.
	assert: values size equals: 9.
	assert: (values at: 1) equals: 'rouge'.
	assert: (values at: 2) equals: 'orange'.
	assert: (values at: 3) equals: 'jaune'.
	assert: (values at: 4) equals: 'vert'.
	assert: (values at: 5) equals: 'bleu'.
	assert: (values at: 6) equals: 'violet'.
	assert: (values at: 7) equals: 'blanc'.
	assert: (values at: 8) equals: 'gris'.
	assert: (values at: 9) equals: 'noir'.
)
public testOrderedMapKeysAndValuesDo = (
	| map count |
	map:: OrderedMap new.
	map at: 'red' put: 'rouge'.
	map at: 'blue' put: 'bleu'.
	map removeKey: 'blue'.
	count:: 0.
	map keysAndValuesDo:
		[:key :value |
		 assert: key equals: 'red'.
		 assert: value equals: 'rouge'.
		 count:: count + 1].
	assert: count equals: 1.
)
public testOrderedMapLowCapacity = (
	(* Regression test against naively taking the capacity hint, which can break the invariant of having at least one free slot. *)
	0 to: 3 do:
		[:capacityHint | | map |
		 map:: OrderedMap new: capacityHint.
		 map at: 'roses' put: 'red'.
		 map at: 'violets' put: 'blue'.
		 assert: map size equals: 2.
		 assert: (map at: 'roses') equals: 'red'.
		 assert: (map at: 'violets') equals: 'blue'].
)
public testOrderedMapNew = (
	assert: (OrderedMap new) size equals: 0.
	assert: (OrderedMap new: 0) size equals: 0.
	assert: (OrderedMap new: 16) size equals: 0.

	should: [OrderedMap new: -1] signal: Error.
	should: [OrderedMap new: '10'] signal: Error.
	should: [OrderedMap new: nil] signal: Error.
)
public testOrderedMapNilKey = (
	| map = OrderedMap new. |
	assert: (map at: nil put: 'pear') equals: 'pear'.
	assert: map size equals: 1.
	assert: (map includesKey: nil).
	assert: (map at: nil) equals: 'pear'.

	(* Try to trigger growth/rehashing. *)
	assert: (map at: 1 put: 'apricot') equals: 'apricot'.
	assert: (map at: 2 put: 'cherry') equals: 'cherry'.
	assert: (map at: 3 put: 'mango') equals: 'mango'.
	assert: (map at: 4 put: 'nectarine') equals: 'nectarine'.
	assert: (map at: 5 put: 'lemon') equals: 'lemon'.
	assert: (map at: 6 put: 'lime') equals: 'lime'.
	assert: (map at: 7 put: 'peach') equals: 'peach'.
	assert: (map at: 8 put: 'plum') equals: 'plum'.

	assert: map size equals: 9.
	assert: (map includesKey: nil).
	assert: (map at: nil) equals: 'pear'.

	assert: (map at: 1) equals: 'apricot'.
	assert: (map at: 2) equals: 'cherry'.
	assert: (map at: 3) equals: 'mango'.
	assert: (map at: 4) equals: 'nectarine'.
	assert: (map at: 5) equals: 'lemon'.
	assert: (map at: 6) equals: 'lime'.
	assert: (map at: 7) equals: 'peach'.
	assert: (map at: 8) equals: 'plum'.

	assert: (map removeKey: nil) equals: 'pear'.
	assert: map size equals: 8.
	deny: (map includesKey: nil).
	assert: (map at: nil put: 'pineapple') equals: 'pineapple'.
	assert: map size equals: 9.
	assert: (map includesKey: nil).
	assert: (map at: nil) equals: 'pineapple'.
)
public testOrderedMapReject = (
	| map result keys values |
	map:: OrderedMap new.
	map at: 'red' put: 'rouge'.
	map at: 'orange' put: 'orange'.
	map at: 'yellow' put: 'jaune'.
	map at: 'green' put: 'vert'.
	map at: 'blue' put: 'bleu'.
	map at: 'purple' put: 'violet'.
	map at: 'white' put: 'blanc'.
	map at: 'gray' put: 'gris'.
	map at: 'black' put: 'noir'.

	result:: map reject: [:each | each size > 4].
	assert: result isKindOfOrderedMap.
	assert: result size equals: 4.

	keys:: result keys.
	assert: keys isKindOfArray.
	assert: keys size equals: 4.
	assert: (keys at: 1) equals: 'green'.
	assert: (keys at: 2) equals: 'blue'.
	assert: (keys at: 3) equals: 'gray'.
	assert: (keys at: 4) equals: 'black'.

	values:: result values.
	assert: values isKindOfArray.
	assert: values size equals: 4.
	assert: (values at: 1) equals: 'vert'.
	assert: (values at: 2) equals: 'bleu'.
	assert: (values at: 3) equals: 'gris'.
	assert: (values at: 4) equals: 'noir'.
)
public testOrderedMapRemoveAll = (
	| map = OrderedMap new: 0. |
	map at: 'apple' put: 'elppa'.
	map at: 'banana' put: 'ananab'.
	map at: 'orange' put: 'egnaro'.
	map at: 'strawberry' put: 'yrrebwarts'.
	map at: 'watermelon' put: 'nolemretaw'.
	assert: map size equals: 5.

	map removeAll.
	assert: map size equals: 0.
	map removeAll.
	assert: map size equals: 0.

	map at: 'apricot' put: 'tocirpa'.
	map at: 'cherry' put: 'yrrehc'.
	map at: 'mango' put: 'ognam'.
	map at: 'nectarine' put: 'eniratcen'.
	map at: 'lemon' put: 'nomel'.
	map at: 'lime' put: 'emil'.
	map at: 'peach' put: 'hcaep'.
	map at: 'plum' put: 'mulp'.
	assert: map size equals: 8.
	assert: (map at: 'apricot') equals: 'tocirpa'.
	assert: (map at: 'cherry') equals: 'yrrehc'.
	assert: (map at: 'mango') equals: 'ognam'.
	assert: (map at: 'nectarine') equals: 'eniratcen'.
	assert: (map at: 'lemon') equals: 'nomel'.
	assert: (map at: 'lime') equals: 'emil'.
	assert: (map at: 'peach') equals: 'hcaep'.
	assert: (map at: 'plum') equals: 'mulp'.

	map removeAll.
	assert: map size equals: 0.
)
public testOrderedMapScalingContiguousHashes = (
	(* Test will be noticeably slow if implementation is quadratic *)
	| n map |
	n:: 10000.
	map:: OrderedMap new.
	1 to: n do: [:i | map at: i put: i * 2].
	assert: map size equals: n.
	1 to: n do: [:i | assert: (map at: i) equals: i * 2].
	1 to: n do: [:i | map removeKey: i].
	assert: map size equals: 0.
	1 to: n do: [:i | deny: (map includesKey: i)].

	map:: OrderedMap new.
	n to: 1 by: -1 do: [:i | map at: i put: i * 2].
	assert: map size equals: n.
	n to: 1 by: -1 do: [:i | assert: (map at: i) equals: i * 2].
	n to: 1 by: -1 do: [:i | map removeKey: i].
	assert: map size equals: 0.
	n to: 1 by: -1 do: [:i | deny: (map includesKey: i)].
)
public testOrderedMapSelect = (
	| map result keys values |
	map:: OrderedMap new.
	map at: 'red' put: 'rouge'.
	map at: 'orange' put: 'orange'.
	map at: 'yellow' put: 'jaune'.
	map at: 'green' put: 'vert'.
	map at: 'blue' put: 'bleu'.
	map at: 'purple' put: 'violet'.
	map at: 'white' put: 'blanc'.
	map at: 'gray' put: 'gris'.
	map at: 'black' put: 'noir'.

	result:: map select: [:each | each size > 4].
	assert: result isKindOfOrderedMap.
	assert: result size equals: 5.

	keys:: result keys.
	assert: keys isKindOfArray.
	assert: keys size equals: 5.
	assert: (keys at: 1) equals: 'red'.
	assert: (keys at: 2) equals: 'orange'.
	assert: (keys at: 3) equals: 'yellow'.
	assert: (keys at: 4) equals: 'purple'.
	assert: (keys at: 5) equals: 'white'.

	values:: result values.
	assert: values isKindOfArray.
	assert: values size equals: 5.
	assert: (values at: 1) equals: 'rouge'.
	assert: (values at: 2) equals: 'orange'.
	assert: (values at: 3) equals: 'jaune'.
	assert: (values at: 4) equals: 'violet'.
	assert: (values at: 5) equals: 'blanc'.
)
public testOrderedMapSelfKey = (
	| map = OrderedMap new. |
	assert: (map at: map put: 'pear') equals: 'pear'.
	assert: map size equals: 1.
	assert: (map includesKey: map).
	assert: (map at: map) equals: 'pear'.

	(* Try to trigger growth/rehashing. *)
	assert: (map at: 1 put: 'apricot') equals: 'apricot'.
	assert: (map at: 2 put: 'cherry') equals: 'cherry'.
	assert: (map at: 3 put: 'mango') equals: 'mango'.
	assert: (map at: 4 put: 'nectarine') equals: 'nectarine'.
	assert: (map at: 5 put: 'lemon') equals: 'lemon'.
	assert: (map at: 6 put: 'lime') equals: 'lime'.
	assert: (map at: 7 put: 'peach') equals: 'peach'.
	assert: (map at: 8 put: 'plum') equals: 'plum'.

	assert: map size equals: 9.
	assert: (map includesKey: map).
	assert: (map at: map) equals: 'pear'.

	assert: (map at: 1) equals: 'apricot'.
	assert: (map at: 2) equals: 'cherry'.
	assert: (map at: 3) equals: 'mango'.
	assert: (map at: 4) equals: 'nectarine'.
	assert: (map at: 5) equals: 'lemon'.
	assert: (map at: 6) equals: 'lime'.
	assert: (map at: 7) equals: 'peach'.
	assert: (map at: 8) equals: 'plum'.

	assert: (map removeKey: map) equals: 'pear'.
	assert: map size equals: 8.
	deny: (map includesKey: map).
	assert: (map at: map put: 'pineapple') equals: 'pineapple'.
	assert: map size equals: 9.
	assert: (map includesKey: map).
	assert: (map at: map) equals: 'pineapple'.
)
public testOrderedMapUpdates = (
	| map result |
	map:: OrderedMap new.
	map at: 'red' put: 'red'.
	map at: 'orange' put: 'orange'.
	map at: 'yellow' put: 'yellow'.
	map at: 'green' put: 'green'.
	map at: 'blue' put: 'blue'.
	map at: 'purple' put: 'purple'.
	map at: 'white' put: 'white'.
	map at: 'gray' put: 'gray'.
	map at: 'black' put: 'black'.

	map at: 'red' put: 'rouge'.
	map at: 'orange' put: 'orange'.
	map at: 'yellow' put: 'jaune'.
	map at: 'green' put: 'vert'.
	map at: 'blue' put: 'bleu'.
	map at: 'purple' put: 'violet'.
	map at: 'white' put: 'blanc'.
	map at: 'gray' put: 'gris'.
	map at: 'black' put: 'noir'.

	assert: map size equals: 9.
	assert: (map at: 'red') equals: 'rouge'.
	assert: (map at: 'orange') equals: 'orange'.
	assert: (map at: 'yellow') equals: 'jaune'.
	assert: (map at: 'green') equals: 'vert'.
	assert: (map at: 'blue') equals: 'bleu'.
	assert: (map at: 'purple') equals: 'violet'.
	assert: (map at: 'white') equals: 'blanc'.
	assert: (map at: 'gray') equals: 'gris'.
	assert: (map at: 'black') equals: 'noir'.
)
public testOrderedMapWithAll = (
	| source map keys |
	source:: OrderedMap new.
	source at: 'red' put: 'rouge'.
	source at: 'green' put: 'vert'.
	source at: 'blue' put: 'bleu'.

	map:: OrderedMap withAll: source.
	map at: 'yellow' put: 'jaune'.

	map addAll: source.
	assert: map size equals: 4.
	assert: (map at: 'red') equals: 'rouge'.
	assert: (map at: 'blue') equals: 'bleu'.
	assert: (map at: 'green') equals: 'vert'.
	assert: (map at: 'yellow') equals: 'jaune'.

	map addAll: {true}.
	assert: map size equals: 5.
	assert: (map at: 1) equals: true.

	keys:: map keys.
	assert: (keys at: 1) equals: 'red'.
	assert: (keys at: 2) equals: 'green'.
	assert: (keys at: 3) equals: 'blue'.
	assert: (keys at: 4) equals: 'yellow'.
	assert: (keys at: 5) equals: 1.
)
) : (
TEST_CONTEXT = ()
)
public class OrderedSetTests = TestContext () (
public testIsKindOfOrderedSet = (
	deny: {} isKindOfOrderedSet.
	deny: (Array new: 0) isKindOfOrderedSet.
	deny: List new isKindOfOrderedSet.
	deny: Map new isKindOfOrderedSet.
	deny: OrderedMap new isKindOfOrderedSet.
	deny: Set new isKindOfOrderedSet.
	assert: OrderedSet new isKindOfOrderedSet.
	deny: nil isKindOfOrderedSet.
	deny: false isKindOfOrderedSet.
	deny: true isKindOfOrderedSet.
	deny: 0 isKindOfOrderedSet.
)
public testOrderedSetAsArray = (
	| set array |

	set:: OrderedSet new.
	set add: 10.
	array:: set asArray.
	assert: array isKindOfArray.
	assert: array size equals: 1.
	assert: (array at: 1) equals: 10.

	array at: 1 put: 20.
	assert: (set includes: 10).
	deny: (set includes: 20).

	set:: OrderedSet new.
	set add: 30.
	set add: 40.
	set add: 50.
	array:: set asArray.
	assert: array isKindOfArray.
	assert: array size equals: 3.
	assert: (array at: 1) equals: 30.
	assert: (array at: 2) equals: 40.
	assert: (array at: 3) equals: 50.
)
public testOrderedSetDo = (
	| set count |
	set:: OrderedSet new.
	set add: 'red'.
	set add: 'blue'.
	set remove: 'blue'.
	count:: 0.
	set do:
		[:value |
		 assert: value equals: 'red'.
		 count:: count + 1].
	assert: count equals: 1.
)
public testOrderedSetDuplicates = (
	| set = OrderedSet new. |
	set add: 'apple'.
	set add: 'banana'.
	set add: 'cherry'.
	set add: 'cherry'.
	set add: 'banana'.
	set add: 'apple'.
	assert: set size equals: 3.
)
public testOrderedSetEnumeration = (
	| set evens odds sum |
	set:: OrderedSet withAll: {1. 2. 3. 4. 5. 6. 7. 8. 9}.

	evens:: set select: [:e | e \\ 2 = 0].
	assert: evens size equals: 4.

	odds:: set reject: [:e | e \\ 2 = 0].
	assert: odds size equals: 5.

	sum:: set inject: 0 into: [:a :b | a + b].
	assert: sum equals: 45.

	sum:: set reduce: [:a :b | a + b] ifEmpty: [fail].
	assert: sum equals: 45.

	sum:: set reduce: [:a :b | a + b].
	assert: sum equals: 45.

	assert: (set anySatisfy: [:e | e > 0]).
	assert: (set allSatisfy: [:e | e > 0]).
	deny: (set noneSatisfy: [:e | e > 0]).

	deny: (set anySatisfy: [:e | e < 0]).
	deny: (set allSatisfy: [:e | e < 0]).
	assert: (set noneSatisfy: [:e | e < 0]).

	assert: (set detect: [:e | e > 5]) equals: 6.
	assert: (set detect: [:e | e > 55] ifNone: ['None']) equals: 'None'.
)
public testOrderedSetIsEmpty = (
	| set |
	assert: (OrderedSet new: 0) isEmpty.
	assert: (OrderedSet new: 16) isEmpty.

	set:: OrderedSet new.
	assert: set isEmpty.
	set add: #element.
	deny: set isEmpty.
	set remove: #element.
	assert: set isEmpty.
)
public testOrderedSetLowCapacity = (
	(* Regression test against naively taking the capacity hint, which can break the invariant of having at least one free slot. *)
	0 to: 3 do:
		[:capacityHint | | set |
		 set:: OrderedSet new: capacityHint.
		 set add: 'roses'.
		 set add: 'violets'.
		 assert: set size equals: 2.
		 assert: (set includes: 'roses').
		 assert: (set includes: 'violets')].
)
public testOrderedSetNew = (
	assert: (OrderedSet new) size equals: 0.
	assert: (OrderedSet new: 16) size equals: 0.

	should: [OrderedSet new: -1] signal: Error.
	should: [OrderedSet new: '10'] signal: Error.
	should: [OrderedSet new: nil] signal: Error.
)
public testOrderedSetNilElement = (
	| set = OrderedSet new. |
	assert: (set add: nil) equals: nil.
	assert: set size equals: 1.
	assert: (set includes: nil).

	(* Try to trigger growth/rehashing. *)
	assert: (set add: 'apricot') equals: 'apricot'.
	assert: (set add: 'cherry') equals: 'cherry'.
	assert: (set add: 'mango') equals: 'mango'.
	assert: (set add: 'nectarine') equals: 'nectarine'.
	assert: (set add: 'lemon') equals: 'lemon'.
	assert: (set add: 'lime') equals: 'lime'.
	assert: (set add: 'peach') equals: 'peach'.
	assert: (set add: 'plum') equals: 'plum'.

	assert: set size equals: 9.
	assert: (set includes: nil).
	assert: (set includes: 'apricot').
	assert: (set includes: 'cherry').
	assert: (set includes: 'mango').
	assert: (set includes: 'nectarine').
	assert: (set includes: 'lemon').
	assert: (set includes: 'lime').
	assert: (set includes: 'peach').
	assert: (set includes: 'plum').

	assert: (set remove: nil) equals: nil.
	assert: set size equals: 8.
	deny: (set includes: nil).
	assert: (set add: nil) equals: nil.
	assert: set size equals: 9.
	assert: (set includes: nil).
)
public testOrderedSetReject = (
	| set result array |
	set:: OrderedSet new.
	set add: 'red'.
	set add: 'orange'.
	set add: 'yellow'.
	set add: 'green'.
	set add: 'blue'.
	set add: 'purple'.
	set add: 'white'.
	set add: 'gray'.
	set add: 'black'.

	result:: set reject: [:each | each size > 4].
	assert: result isKindOfOrderedSet.
	assert: result size equals: 3.

	array:: result asArray.
	assert: array isKindOfArray.
	assert: array size equals: 3.
	assert: (array at: 1) equals: 'red'.
	assert: (array at: 2) equals: 'blue'.
	assert: (array at: 3) equals: 'gray'.
)
public testOrderedSetRemoveAll = (
	| set = OrderedSet new: 0. |
	set add: 'apple'.
	set add: 'banana'.
	set add: 'orange'.
	set add: 'strawberry'.
	set add: 'watermelon'.
	assert: set size equals: 5.

	set removeAll.
	assert: set size equals: 0.
	set removeAll.
	assert: set size equals: 0.

	set add: 'apricot'.
	set add: 'cherry'.
	set add: 'mango'.
	set add: 'nectarine'.
	set add: 'lemon'.
	set add: 'lime'.
	set add: 'peach'.
	set add: 'plum'.
	assert: set size equals: 8.
	assert: (set includes: 'apricot').
	assert: (set includes: 'cherry').
	assert: (set includes: 'mango').
	assert: (set includes: 'nectarine').
	assert: (set includes: 'lemon').
	assert: (set includes: 'lime').
	assert: (set includes: 'peach').
	assert: (set includes: 'plum').

	set removeAll.
	assert: set size equals: 0.
)
public testOrderedSetScalingContiguousHashes = (
	(* Test will be noticeably slow if implementation is quadratic *)
	| n set |
	n:: 10000.
	set:: OrderedSet new.
	1 to: n do: [:i | set add: i].
	assert: set size equals: n.
	1 to: n do: [:i | assert: (set includes: i)].
	1 to: n do: [:i | set remove: i].
	assert: set size equals: 0.
	1 to: n do: [:i | deny: (set includes: i)].

	set:: OrderedSet new.
	n to: 1 by: -1 do: [:i | set add: i].
	assert: set size equals: n.
	n to: 1 by: -1 do: [:i | assert: (set includes: i)].
	n to: 1 by: -1 do: [:i | set remove: i].
	assert: set size equals: 0.
	n to: 1 by: -1 do: [:i | deny: (set includes: i)].
)
public testOrderedSetSelect = (
	| set result array |
	set:: OrderedSet new.
	set add: 'red'.
	set add: 'orange'.
	set add: 'yellow'.
	set add: 'green'.
	set add: 'blue'.
	set add: 'purple'.
	set add: 'white'.
	set add: 'gray'.
	set add: 'black'.

	result:: set select: [:each | each size > 4].
	assert: result isKindOfOrderedSet.
	assert: result size equals: 6.

	array:: result asArray.
	assert: array isKindOfArray.
	assert: array size equals: 6.
	assert: (array at: 1) equals: 'orange'.
	assert: (array at: 2) equals: 'yellow'.
	assert: (array at: 3) equals: 'green'.
	assert: (array at: 4) equals: 'purple'.
	assert: (array at: 5) equals: 'white'.
	assert: (array at: 6) equals: 'black'.
)
public testOrderedSetSelfElement = (
	| set = OrderedSet new. |
	assert: (set add: self) equals: self.
	assert: set size equals: 1.
	assert: (set includes: self).

	(* Try to trigger growth/rehashing. *)
	assert: (set add: 'apricot') equals: 'apricot'.
	assert: (set add: 'cherry') equals: 'cherry'.
	assert: (set add: 'mango') equals: 'mango'.
	assert: (set add: 'nectarine') equals: 'nectarine'.
	assert: (set add: 'lemon') equals: 'lemon'.
	assert: (set add: 'lime') equals: 'lime'.
	assert: (set add: 'peach') equals: 'peach'.
	assert: (set add: 'plum') equals: 'plum'.

	assert: set size equals: 9.
	assert: (set includes: self).
	assert: (set includes: 'apricot').
	assert: (set includes: 'cherry').
	assert: (set includes: 'mango').
	assert: (set includes: 'nectarine').
	assert: (set includes: 'lemon').
	assert: (set includes: 'lime').
	assert: (set includes: 'peach').
	assert: (set includes: 'plum').

	assert: (set remove: self) equals: self.
	assert: set size equals: 8.
	deny: (set includes: self).
	assert: (set add: self) equals: self.
	assert: set size equals: 9.
	assert: (set includes: self).
)
public testOrderedSetWithAll = (
	| array bytearray list result |
	array:: Array new: 2.
	array at: 1 put: 'A'.
	array at: 2 put: 'B'.
	result:: OrderedSet withAll: array.
	assert: result size equals: 2.
	assert: (result includes: 'A').
	assert: (result includes: 'B').

	bytearray:: ByteArray new: 2.
	bytearray at: 1 put: 67.
	bytearray at: 2 put: 68.
	result:: OrderedSet withAll: bytearray.
	assert: result size equals: 2.
	assert: (result includes: 67).
	assert: (result includes: 68).

	result:: OrderedSet withAll: 'EF'.
	assert: result size equals: 2.
	assert: (result includes: 69).
	assert: (result includes: 70).

	list:: List new.
	list add: 'G'.
	list add: 'H'.
	result:: OrderedSet withAll: list.
	assert: result size equals: 2.
	assert: (result includes: 'G').
	assert: (result includes: 'H').

	should: [OrderedSet withAll: -1] signal: Error.
	should: [OrderedSet withAll: 16r110000] signal: Error.
	should: [OrderedSet withAll: nil] signal: Error.
	should: [OrderedSet withAll: 122 asFloat] signal: Error.
)
) : (
TEST_CONTEXT = ()
)
public class SetTests = TestContext () (
public testIsKindOfSet = (
	deny: {} isKindOfSet.
	deny: (Array new: 0) isKindOfSet.
	deny: List new isKindOfSet.
	deny: Map new isKindOfSet.
	deny: OrderedMap new isKindOfSet.
	assert: Set new isKindOfSet.
	assert: OrderedSet new isKindOfSet.
	deny: nil isKindOfSet.
	deny: false isKindOfSet.
	deny: true isKindOfSet.
	deny: 0 isKindOfSet.
)
public testSetAsArray = (
	| set array |

	set:: Set new.
	set add: 10.
	array:: set asArray.
	assert: array isKindOfArray.
	assert: array size equals: 1.
	assert: (array at: 1) equals: 10.

	array at: 1 put: 20.
	assert: (set includes: 10).
	deny: (set includes: 20).

	set:: Set new.
	set add: 30.
	set add: 40.
	set add: 50.
	array:: set asArray.
	assert: array isKindOfArray.
	assert: array size equals: 3.
	array sort: [:a :b | a <= b].
	assert: (array at: 1) equals: 30.
	assert: (array at: 2) equals: 40.
	assert: (array at: 3) equals: 50.
)
public testSetDo = (
	| set count |
	set:: Set new.
	set add: 'red'.
	set add: 'blue'.
	set remove: 'blue'.
	count:: 0.
	set do:
		[:value |
		 assert: value equals: 'red'.
		 count:: count + 1].
	assert: count equals: 1.
)
public testSetDuplicates = (
	| set = Set new. |
	set add: 'apple'.
	set add: 'banana'.
	set add: 'cherry'.
	set add: 'cherry'.
	set add: 'banana'.
	set add: 'apple'.
	assert: set size equals: 3.
)
public testSetEnumeration = (
	| set evens odds sum |
	set:: Set withAll: {1. 2. 3. 4. 5. 6. 7. 8. 9}.

	evens:: set select: [:e | e \\ 2 = 0].
	assert: evens size equals: 4.

	odds:: set reject: [:e | e \\ 2 = 0].
	assert: odds size equals: 5.

	sum:: set inject: 0 into: [:a :b | a + b].
	assert: sum equals: 45.

	sum:: set reduce: [:a :b | a + b] ifEmpty: [fail].
	assert: sum equals: 45.

	sum:: set reduce: [:a :b | a + b].
	assert: sum equals: 45.

	assert: (set anySatisfy: [:e | e > 0]).
	assert: (set allSatisfy: [:e | e > 0]).
	deny: (set noneSatisfy: [:e | e > 0]).

	deny: (set anySatisfy: [:e | e < 0]).
	deny: (set allSatisfy: [:e | e < 0]).
	assert: (set noneSatisfy: [:e | e < 0]).

	assert: (set detect: [:e | e > 5]) equals: 6.
	assert: (set detect: [:e | e > 55] ifNone: ['None']) equals: 'None'.
)
public testSetIsEmpty = (
	| set |
	assert: (Set new: 0) isEmpty.
	assert: (Set new: 16) isEmpty.

	set:: Set new.
	assert: set isEmpty.
	set add: #element.
	deny: set isEmpty.
	set remove: #element.
	assert: set isEmpty.
)
public testSetLowCapacity = (
	(* Regression test against naively taking the capacity hint, which can break the invariant of having at least one free slot. *)
	0 to: 3 do:
		[:capacityHint | | set |
		 set:: Set new: capacityHint.
		 set add: 'roses'.
		 set add: 'violets'.
		 assert: set size equals: 2.
		 assert: (set includes: 'roses').
		 assert: (set includes: 'violets')].
)
public testSetNew = (
	assert: (Set new) size equals: 0.
	assert: (Set new: 16) size equals: 0.

	should: [Set new: -1] signal: Error.
	should: [Set new: '10'] signal: Error.
	should: [Set new: nil] signal: Error.
)
public testSetNilElement = (
	| set = Set new. |
	assert: (set add: nil) equals: nil.
	assert: set size equals: 1.
	assert: (set includes: nil).

	(* Try to trigger growth/rehashing. *)
	assert: (set add: 'apricot') equals: 'apricot'.
	assert: (set add: 'cherry') equals: 'cherry'.
	assert: (set add: 'mango') equals: 'mango'.
	assert: (set add: 'nectarine') equals: 'nectarine'.
	assert: (set add: 'lemon') equals: 'lemon'.
	assert: (set add: 'lime') equals: 'lime'.
	assert: (set add: 'peach') equals: 'peach'.
	assert: (set add: 'plum') equals: 'plum'.

	assert: set size equals: 9.
	assert: (set includes: nil).
	assert: (set includes: 'apricot').
	assert: (set includes: 'cherry').
	assert: (set includes: 'mango').
	assert: (set includes: 'nectarine').
	assert: (set includes: 'lemon').
	assert: (set includes: 'lime').
	assert: (set includes: 'peach').
	assert: (set includes: 'plum').

	assert: (set remove: nil) equals: nil.
	assert: set size equals: 8.
	deny: (set includes: nil).
	assert: (set add: nil) equals: nil.
	assert: set size equals: 9.
	assert: (set includes: nil).
)
public testSetRemoveAll = (
	| set = Set new: 0. |
	set add: 'apple'.
	set add: 'banana'.
	set add: 'orange'.
	set add: 'strawberry'.
	set add: 'watermelon'.
	assert: set size equals: 5.

	set removeAll.
	assert: set size equals: 0.
	set removeAll.
	assert: set size equals: 0.

	set add: 'apricot'.
	set add: 'cherry'.
	set add: 'mango'.
	set add: 'nectarine'.
	set add: 'lemon'.
	set add: 'lime'.
	set add: 'peach'.
	set add: 'plum'.
	assert: set size equals: 8.
	assert: (set includes: 'apricot').
	assert: (set includes: 'cherry').
	assert: (set includes: 'mango').
	assert: (set includes: 'nectarine').
	assert: (set includes: 'lemon').
	assert: (set includes: 'lime').
	assert: (set includes: 'peach').
	assert: (set includes: 'plum').

	set removeAll.
	assert: set size equals: 0.
)
public testSetScalingContiguousHashes = (
	(* Test will be noticeably slow if implementation is quadratic *)
	| n set |
	n:: 10000.
	set:: Set new.
	1 to: n do: [:i | set add: i].
	assert: set size equals: n.
	1 to: n do: [:i | assert: (set includes: i)].

	set:: Set new.
	n to: 1 by: -1 do: [:i | set add: i].
	assert: set size equals: n.
	n to: 1 by: -1 do: [:i | assert: (set includes: i)].
)
public testSetSelfElement = (
	| set = Set new. |
	assert: (set add: self) equals: self.
	assert: set size equals: 1.
	assert: (set includes: self).

	(* Try to trigger growth/rehashing. *)
	assert: (set add: 'apricot') equals: 'apricot'.
	assert: (set add: 'cherry') equals: 'cherry'.
	assert: (set add: 'mango') equals: 'mango'.
	assert: (set add: 'nectarine') equals: 'nectarine'.
	assert: (set add: 'lemon') equals: 'lemon'.
	assert: (set add: 'lime') equals: 'lime'.
	assert: (set add: 'peach') equals: 'peach'.
	assert: (set add: 'plum') equals: 'plum'.

	assert: set size equals: 9.
	assert: (set includes: self).
	assert: (set includes: 'apricot').
	assert: (set includes: 'cherry').
	assert: (set includes: 'mango').
	assert: (set includes: 'nectarine').
	assert: (set includes: 'lemon').
	assert: (set includes: 'lime').
	assert: (set includes: 'peach').
	assert: (set includes: 'plum').

	assert: (set remove: self) equals: self.
	assert: set size equals: 8.
	deny: (set includes: self).
	assert: (set add: self) equals: self.
	assert: set size equals: 9.
	assert: (set includes: self).
)
public testSetWithAll = (
	| array bytearray list result |
	array:: Array new: 2.
	array at: 1 put: 'A'.
	array at: 2 put: 'B'.
	result:: Set withAll: array.
	assert: result size equals: 2.
	assert: (result includes: 'A').
	assert: (result includes: 'B').

	bytearray:: ByteArray new: 2.
	bytearray at: 1 put: 67.
	bytearray at: 2 put: 68.
	result:: Set withAll: bytearray.
	assert: result size equals: 2.
	assert: (result includes: 67).
	assert: (result includes: 68).

	result:: Set withAll: 'EF'.
	assert: result size equals: 2.
	assert: (result includes: 69).
	assert: (result includes: 70).

	list:: List new.
	list add: 'G'.
	list add: 'H'.
	result:: Set withAll: list.
	assert: result size equals: 2.
	assert: (result includes: 'G').
	assert: (result includes: 'H').

	should: [Set withAll: -1] signal: Error.
	should: [Set withAll: 16r110000] signal: Error.
	should: [Set withAll: nil] signal: Error.
	should: [Set withAll: 122 asFloat] signal: Error.
)
) : (
TEST_CONTEXT = ()
)
rangeError = (
	(* :todo: Introduce a more specific exception. *)
	^Error
)
) : (
)
